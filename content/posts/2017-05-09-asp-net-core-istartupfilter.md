---
title: ASP.NET Core ‚Äì IStartupFilter

author: eiximenis

date: 2017-05-09T14:55:27+00:00
geeks_url: /?p=1874
geeks_ms_views:
  - 1532
categories:
  - asp.net 5
  - asp.net vNext
  - netcore

---
Buenas! Vamos a explorar en este post la interfaz **IStartupFilter**, por lo general un desconocido de ASP.NET Core, pero bueno‚Ä¶ que est√° por ah√≠ y no est√° de m√°s conocerlo un poco. ¬°Vamos all√°!

<!--more-->


  
**Middlewares**
  
En este punto voy a asumir que todos conocemos el concepto de _middleware_ de asp.net core, ¬øno? Si alguien no lo conoce, es de [lectura obligatoria este post][1] del maestro [Jose Mar√≠a Aguilar][2].
  
Bueno, pues eso‚Ä¶ ahora ya sabemos que los middlewares en ASP.NET Core son los encargados de ir procesando las peticiones. La petici√≥n viaja por todos los middlewares y cada uno de ellos puede realizar distintas tareas (entre ellas modificar la petici√≥n o el contexto http) y luego o bien pasar la petici√≥n al siguiente middleware o bien cortocircuitar y devolver una respuesta‚Ä¶ Respuesta que viaja otra vez por la cadena de middlewares (en orden inverso) donde de nuevo puede ser procesada por cada uno de ellos hasta ser enviada al navegador.
  
Veamos un ejemplo de middleware, que nos permite **cortocircuitar cualquier petici√≥n y mandar un 500** o bien no hacer nada. Esto nos permitir√≠a de forma f√°cil poner un servicio ‚Äúen modo de fallos‚Äù para probar distintas casu√≠sticas. En github est√° el [c√≥digo entero del middleware][3], por si quer√©is echarle un ojo. Hay tres ficheros. El primero es **FailingMiddleware.cs** que contiene el _middleware_ en s√≠. Este _middleware_ tiene una variable (__mustFail_) y si dicha variable value _true_, el middleware cortocircuita todas las peticiones y env√≠a un 500:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">async</span>&nbsp;<span style="color: #4ec9b0">Task</span> Invoke(<span style="color: #4ec9b0">HttpContext</span> context)<br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">var</span> path <span style="color: #b4b4b4">=</span> context<span style="color: #b4b4b4">.</span>Request<span style="color: #b4b4b4">.</span>Path;<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">if</span> (path<span style="color: #b4b4b4">.</span>Equals(_options<span style="color: #b4b4b4">.</span>ConfigPath, <span style="color: #b8d7a3">StringComparison</span><span style="color: #b4b4b4">.</span>OrdinalIgnoreCase))<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">await</span> ProcessConfigRequest(context);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">return</span>;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">if</span> (_mustFail)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context<span style="color: #b4b4b4">.</span>Response<span style="color: #b4b4b4">.</span>StatusCode <span style="color: #b4b4b4">=</span> (<span style="color: #569cd6">int</span>)System<span style="color: #b4b4b4">.</span>Net<span style="color: #b4b4b4">.</span><span style="color: #b8d7a3">HttpStatusCode</span><span style="color: #b4b4b4">.</span>InternalServerError;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context<span style="color: #b4b4b4">.</span>Response<span style="color: #b4b4b4">.</span>ContentType <span style="color: #b4b4b4">=</span>&nbsp;<span style="color: #d69d85">"text/plain"</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">await</span> context<span style="color: #b4b4b4">.</span>Response<span style="color: #b4b4b4">.</span>WriteAsync(<span style="color: #d69d85">"Failed due to FailingMiddleware enabled."</span>);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">else</span><br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">await</span> _next<span style="color: #b4b4b4">.</span>Invoke(context);<br />&nbsp;&nbsp;&nbsp; }<br />}</pre>

Se puede ver que si __mustFail_ vale true se env√≠a un 500 y si no, entonces se pasa la request al siguiente middleware. Por supuesto se ofrece un endpoint (en __options.ConfigPath_) que permite habilitar y deshabilitar este middleware.
  
El fichero **FailingMiddlewareAppBuilderExtensions.cs** contiene los m√©todos de extensi√≥n que nos permiten ‚Äúenchufar‚Äù este middleware de forma f√°cil:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #b8d7a3">IApplicationBuilder</span> UseFailingMiddleware(<span style="color: #569cd6">this</span>&nbsp;<span style="color: #b8d7a3">IApplicationBuilder</span> builder)<br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">return</span> UseFailingMiddleware(builder, <span style="color: #569cd6">null</span>);<br />}<br /><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #b8d7a3">IApplicationBuilder</span> UseFailingMiddleware(<span style="color: #569cd6">this</span>&nbsp;<span style="color: #b8d7a3">IApplicationBuilder</span> builder, <span style="color: #4ec9b0">Action</span>&lt;<span style="color: #4ec9b0">FailingOptions</span>&gt; action)<br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">var</span> options <span style="color: #b4b4b4">=</span>&nbsp;<span style="color: #569cd6">new</span>&nbsp;<span style="color: #4ec9b0">FailingOptions</span>();<br />&nbsp;&nbsp;&nbsp; action<span style="color: #b4b4b4">?.</span>Invoke(options);<br />&nbsp;&nbsp;&nbsp; builder<span style="color: #b4b4b4">.</span>UseMiddleware&lt;<span style="color: #4ec9b0">FailingMiddleware</span>&gt;(options);<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">return</span> builder;<br />}</pre>

El √∫ltimo fichero es **FailingOptions.cs** que contiene la clase _FailingOptions_ que se usa para configurar el middleware&nbsp; (a trav√©s del m√©todo de extensi√≥n) de una forma como la siguiente (y indicar el endpoint para configurar el middleware):

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro">app<span style="color: #b4b4b4">.</span>UseFailingMiddleware(options <span style="color: #b4b4b4">=&gt;</span><br />{<br />&nbsp;&nbsp;&nbsp; options<span style="color: #b4b4b4">.</span>ConfigPath <span style="color: #b4b4b4">=</span>&nbsp;<span style="color: #d69d85">"/FailingEndpoint"</span>;<br />});</pre>

Si enchufamos este middleware antes de cualquier otro (y lo habilitamos llamando a su endpoint) cualquier otra petici√≥n devolver√° siempre un 500 (hasta que lo deshabilitemos otra vez).
  
**IStartupFilter**
  
Vale, veamos ahora que rol juega esta interfaz. Empezaremos por su declaraci√≥n:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">namespace</span> Microsoft<span style="color: #b4b4b4">.</span>AspNetCore<span style="color: #b4b4b4">.</span>Hosting<br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">interface</span>&nbsp;<span style="color: #b8d7a3">IStartupFilter</span><br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #4ec9b0">Action</span>&lt;<span style="color: #b8d7a3">IApplicationBuilder</span>&gt; Configure(<span style="color: #4ec9b0">Action</span>&lt;<span style="color: #b8d7a3">IApplicationBuilder</span>&gt; next);<br />&nbsp;&nbsp;&nbsp; }<br />}</pre>

Tiene un solo m√©todo que toma un Action<IApplicationBuilder> y devuelve un Action<IApplicationBuilder>. Vale, eso no nos dice mucho, pero la idea es la siguiente: **un filtro de startup es un elemento que nos permite hacer ‚Äúalgo‚Äù (lo que queramos) con el IApplicationBuilder _<u>incluso antes que se ejecute el c√≥digo de Startup.</u>_**
  
Solemos pensar que el punto de entrada de una aplicaci√≥n ASP.NET Core, es la clase _Startup_. Esa percepci√≥n viene seguramente de los tiempos de OWIN, donde eso era as√≠ (el c√≥digo que llamaba a Startup formaba parte del framework y no lo ten√≠amos en nuestro proyecto) pero en ASP.NET Core eso es falso. En efecto, las aplicaciones ASP.NET Core son, en el fondo, aplicaciones de consola y si buscas en tu proyecto encontrar√°s el fichero Program.cs:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">class</span>&nbsp;<span style="color: #4ec9b0">Program</span><br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #569cd6">void</span> Main(<span style="color: #569cd6">string</span>[] args)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">var</span> host <span style="color: #b4b4b4">=</span>&nbsp;<span style="color: #569cd6">new</span>&nbsp;<span style="color: #4ec9b0">WebHostBuilder</span>()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseKestrel()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseContentRoot(<span style="color: #4ec9b0">Directory</span><span style="color: #b4b4b4">.</span>GetCurrentDirectory())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseIISIntegration()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseStartup&lt;<span style="color: #4ec9b0">Startup</span>&gt;()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>Build();<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host<span style="color: #b4b4b4">.</span>Run();<br />&nbsp;&nbsp;&nbsp; }<br />}</pre>

Este **es el verdadero punto de entrada** de una aplicaci√≥n ASP.NET Core. ¬øVes el m√©todo ‚ÄúUseStartup‚Äù? Pues ese es el m√©todo que cede el control a la clase _Startup_ que tenemos en nuestro proyecto. **Observa que realmente, adem√°s del pipeline de middlewares que tenemos en _Startup_ existe ‚Äúotro pipeline‚Äù constru√≠do sobre WebHostBuilder**. Este otro pipeline es el que establecemos usando IStartupFilter. La diferencia es que no es un pipeline de middlewares si no un pipeline de‚Ä¶ configuraciones üôÇ
  
Veamos un ejemplo de ello. Para ello vamos a crear un filtro de startup:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">class</span>&nbsp;<span style="color: #4ec9b0">FailingStartupFilter</span> : <span style="color: #b8d7a3">IStartupFilter</span><br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">private</span>&nbsp;<span style="color: #569cd6">readonly</span>&nbsp;<span style="color: #569cd6">string</span> _path;<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">public</span> FailingStartupFilter(<span style="color: #569cd6">string</span> path)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _path <span style="color: #b4b4b4">=</span> path;<br />&nbsp;&nbsp;&nbsp; }<br /> <br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">public</span>&nbsp;<span style="color: #4ec9b0">Action</span>&lt;<span style="color: #b8d7a3">IApplicationBuilder</span>&gt; Configure(<span style="color: #4ec9b0">Action</span>&lt;<span style="color: #b8d7a3">IApplicationBuilder</span>&gt; next)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">return</span> app <span style="color: #b4b4b4">=&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app<span style="color: #b4b4b4">.</span>UseFailingMiddleware(options <span style="color: #b4b4b4">=&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; options<span style="color: #b4b4b4">.</span>ConfigPath <span style="color: #b4b4b4">=</span> _path;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next(app);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; }<br />}</pre>

Vale, podemos ver lo simple que es. Al final simplemente debemos colocar el c√≥digo en el m√©todo Configure. **La clave es entender que este m√©todo Configure hace lo mismo que el m√©todo Configure de la clase Startup**. En este caso, lo que hacemos es agregar el _FailingMiddleware_ que hemos visto antes, pero podr√≠amos agregar varios. Este es uno de los usos habituales de los filtros de startup: agregar N middlewares que van todos ellos juntos, lo que puede ser √∫til si desarrollas librer√≠as.
  
Ahora nos falta ver como lo invocamos. Pues es muy sencillo, para ello creamos un m√©todo de extensi√≥n sobre IWebHostBuilder:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #569cd6">class</span>&nbsp;<span style="color: #4ec9b0">WebHostBuildertExtensions</span><br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #b8d7a3">IWebHostBuilder</span> UseFailing(<span style="color: #569cd6">this</span>&nbsp;<span style="color: #b8d7a3">IWebHostBuilder</span> builder, <span style="color: #569cd6">string</span> path)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; builder<span style="color: #b4b4b4">.</span>ConfigureServices(services <span style="color: #b4b4b4">=&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #57a64a">// Registrar el propio filtro</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; services<span style="color: #b4b4b4">.</span>AddSingleton&lt;<span style="color: #b8d7a3">IStartupFilter</span>&gt;(<span style="color: #569cd6">new</span>&nbsp;<span style="color: #4ec9b0">FailingStartupFilter</span>(path));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">return</span> builder;<br />&nbsp;&nbsp;&nbsp; }<br /> <br />}</pre>

B√°sicamente registramos el filtro como singleton, con el tipo **IStartupFilter** (observa que aqu√≠ podr√≠as registrar m√°s elementos si quisieras). Y ahora por supuesto ya puedes a√±adir tu filtro en Program.cs:

<pre style="font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro"><span style="color: #569cd6">public</span>&nbsp;<span style="color: #569cd6">static</span>&nbsp;<span style="color: #569cd6">void</span> Main(<span style="color: #569cd6">string</span>[] args)<br />{<br />&nbsp;&nbsp;&nbsp; <span style="color: #569cd6">var</span> host <span style="color: #b4b4b4">=</span>&nbsp;<span style="color: #569cd6">new</span>&nbsp;<span style="color: #4ec9b0">WebHostBuilder</span>()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseKestrel()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseFailing(<span style="color: #d69d85">"/failing"</span>)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseContentRoot(<span style="color: #4ec9b0">Directory</span><span style="color: #b4b4b4">.</span>GetCurrentDirectory())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseIISIntegration()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseStartup&lt;<span style="color: #4ec9b0">Startup</span>&gt;()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>UseApplicationInsights()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #b4b4b4">.</span>Build();<br /> <br />&nbsp;&nbsp;&nbsp; host<span style="color: #b4b4b4">.</span>Run();<br />}</pre>

Observa como lo hemos a√±adido despu√©s del ‚ÄúUseKestrel‚Äù. ¬øQu√© conseguimos con esto? Pues **instalar el FailingMiddleware delante de cualquier otro middleware que el desarrollador ponga en su Startup**. Algo que en algunos escenarios puede ser muy interesante.
  
Si te preguntas quien es el encargado de ‚Äúprocesar todos los IStartupFilter‚Äù que tenemos, pues‚Ä¶ es el m√©todo Build(). Es este m√©todo quien recoje todos los IStartupFilter y va llamando a sus m√©todos _Configure_ y configura de esa manera la aplicaci√≥n.
  
**¬øCuando usar IStartupFilter?**
  
Pues por norma general dir√≠a que no veo muchos escenarios para hacerlo, a no ser que construyas una librer√≠a que requiera realizar ciertas tareas antes del Startup (o bien despu√©s). En aplicaciones normales no veo que sea necesario bajar a este nivel, cuando la configuraci√≥n tradicional mediante Startup es m√°s que suficiente.
  
Espero que te haya resultado interesante üòâ

 [1]: http://www.variablenotfound.com/2015/12/custom-middlewares-en-aspnet-5.html
 [2]: https://twitter.com/jmaguilar
 [3]: https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.API/Infrastructure/Middlewares