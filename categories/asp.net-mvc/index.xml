<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>asp.net MVC on Lo Cresti√†</title><link>https://www.eiximenis.dev/categories/asp.net-mvc/</link><description>Recent content in asp.net MVC on Lo Cresti√†</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Fri, 29 Jul 2016 08:21:05 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/asp.net-mvc/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET MVC 5‚ÄìBinding de par√°metros din√°micos</title><link>https://www.eiximenis.dev/posts/2016-07-29-asp-net-mvc-5binding-de-parmetros-dinmicos/</link><pubDate>Fri, 29 Jul 2016 08:21:05 +0000</pubDate><atom:modified>Fri, 29 Jul 2016 08:21:05 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-07-29-asp-net-mvc-5binding-de-parmetros-dinmicos/</guid><description>&lt;p>Estando trabajando en un proyecto con ASP.NET MVC 5 surgi√≥ la ‚Äúnecesidad‚Äù (impulsada por la pereza) de tener un controlador MVC (ojo, no WebApi) que recibiese datos en JSON via POST y que devolviese una vista parcial. Hasta ah√≠ nada raro (eso se soporta de serie desde MVC3), donde la pereza intervino es que quer√≠amos que el par√°metro del controlador fuese dynamic en lugar de un tipo en concreto. Y eso, en MVC5 no est√° soportado. Veamos por qu√© y como podemos solucionarlo üòâ&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net MVC</category></item><item><title>Atributos con comportamiento: un mal dise√±o</title><link>https://www.eiximenis.dev/posts/2016-07-01-atributos-con-comportamiento-un-mal-diseo/</link><pubDate>Fri, 01 Jul 2016 10:17:29 +0000</pubDate><atom:modified>Fri, 01 Jul 2016 10:17:29 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-07-01-atributos-con-comportamiento-un-mal-diseo/</guid><description>Tarde o temprano, todo desarrollador ya se de ASP.NET MVC o WebApi necesita hacer sus propios filtros para validaciones propias de peticiones, logging, comprobaci√≥n de precondiciones‚Ä¶ En fin, lo habitual para lo que se usan los filtros, vamos.
Y tarde o temprano este desarrollador se da cuenta de que su filtro deber√≠a acceder a un determinado servicio de su aplicaci√≥n: quiz√° necesita hacer una consulta a la bbdd, o a un determinado elemento de negocio, o acceder al sistema de logging o cualquier cosa m√°s.</description><dc:creator>eiximenis</dc:creator><category>asp.net MVC</category><category>patrones</category></item><item><title>Creando formateadores de salida en asp.net core</title><link>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</link><pubDate>Thu, 21 Apr 2016 07:51:29 +0000</pubDate><atom:modified>Thu, 21 Apr 2016 07:51:29 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</guid><description>&lt;p>Cuando sali√≥ WebApi lo hizo con la negociaci√≥n de contenido incorporada de serie en el framework. Eso ven√≠a a significar, b√°sicamente, que el framework intentaba suministrar los datos en el formato en que el cliente los hab√≠a pedido. La negociaci√≥n de contenido se basa (generalmente) en el uso de la cabecera &lt;em>accept&lt;/em> de HTTP: el cliente manda en esa cabecera cual, o cuales, son sus formatos de respuesta preferidos. WebApi soporta de serie devolver datos en JSON y XML y el sistema es extensible para crear nuestros propios formatos.&lt;/p>
&lt;p>‚ÄúMVC cl√°sico‚Äù (es decir hasta MVC5) no incluye soporte de negociaci√≥n de contenido: en MVC si queremos devolver datos en formato JSON, debemos devolver expl√≠citamente un JsonResult y si los queremos devolver en XML debemos hacerlo tambi√©n expl√≠citamente.&lt;/p>
&lt;p>En ASP.NET Core tenemos a MVC6 que unifica a WebApi y MVC cl√°sico en un solo framework. ¬øComo queda el soporte para negociaci√≥n de contenido en MVC6? Pues bien, existe soporte para ella, pero dependiendo de que IActionResult devolvamos en nuestros controladores. As√≠, si en WebApi la negociaci√≥n de contenido se usaba siempre y en MVC cl√°sico nunca, &lt;strong>en MVC6 la negociaci√≥n de contenido aplica solo si la acci√≥n del controlador devuelve un ObjectResult (o derivado)&lt;/strong>. Esto nos permite como desarrolladores decidir sobre qu√© acciones de qu√© controladores queremos aplicar la negociaci√≥n de contenido. Es evidente que aplicarla siempre no tiene sentido: si devolvemos una vista Razor su resultado debe ser s√≠ o s√≠ un HTML que se env√≠a al cliente. No tendr√≠a sentido aplicar negociaci√≥n de contenido sobre una acci√≥n que devolviese una vista. De hecho la negociaci√≥n de contenido tiene sentido en APIs que devuelvan datos (no vistas) y en MVC6 para devolver datos tenemos a ObjectResult, as√≠ que es l√≥gico que sea sobre este resultado donde se aplique la negociaci√≥n de contenido.&lt;/p>
&lt;p>En WebApi la negociaci√≥n de contenido estaba gestionada por los formateadores (&lt;em>formatters&lt;/em>). B√°sicamente a cada &lt;em>content-type&lt;/em> se le asociaba un formateador. Si el cliente ped√≠a datos en un determinado content-type se miraba que formateador pod√≠a devolver datos en dicho formato. Si no exist√≠a se usaba por defecto el formateador de JSON. En MVC6 se ha mantenido b√°sicamente dicho esquema.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net MVC</category></item></channel></rss>