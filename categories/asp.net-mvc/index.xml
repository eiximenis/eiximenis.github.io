<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>asp.net MVC on Lo Crestià</title><link>https://www.eiximenis.dev/categories/asp.net-mvc/</link><description>Recent content in asp.net MVC on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Fri, 29 Jul 2016 08:21:05 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/asp.net-mvc/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET MVC 5–Binding de parámetros dinámicos</title><link>https://www.eiximenis.dev/posts/2016-07-29-asp-net-mvc-5binding-de-parmetros-dinmicos/</link><pubDate>Fri, 29 Jul 2016 08:21:05 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-07-29-asp-net-mvc-5binding-de-parmetros-dinmicos/</guid><description/></item><item><title>Atributos con comportamiento: un mal diseño</title><link>https://www.eiximenis.dev/posts/2016-07-01-atributos-con-comportamiento-un-mal-diseo/</link><pubDate>Fri, 01 Jul 2016 10:17:29 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-07-01-atributos-con-comportamiento-un-mal-diseo/</guid><description>Tarde o temprano, todo desarrollador ya se de ASP.NET MVC o WebApi necesita hacer sus propios filtros para validaciones propias de peticiones, logging, comprobación de precondiciones… En fin, lo habitual para lo que se usan los filtros, vamos.
Y tarde o temprano este desarrollador se da cuenta de que su filtro debería acceder a un determinado servicio de su aplicación: quizá necesita hacer una consulta a la bbdd, o a un determinado elemento de negocio, o acceder al sistema de logging o cualquier cosa más.</description></item><item><title>Creando formateadores de salida en asp.net core</title><link>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</link><pubDate>Thu, 21 Apr 2016 07:51:29 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</guid><description>&lt;p>Cuando salió WebApi lo hizo con la negociación de contenido incorporada de serie en el framework. Eso venía a significar, básicamente, que el framework intentaba suministrar los datos en el formato en que el cliente los había pedido. La negociación de contenido se basa (generalmente) en el uso de la cabecera &lt;em>accept&lt;/em> de HTTP: el cliente manda en esa cabecera cual, o cuales, son sus formatos de respuesta preferidos. WebApi soporta de serie devolver datos en JSON y XML y el sistema es extensible para crear nuestros propios formatos.&lt;/p>
&lt;p>“MVC clásico” (es decir hasta MVC5) no incluye soporte de negociación de contenido: en MVC si queremos devolver datos en formato JSON, debemos devolver explícitamente un JsonResult y si los queremos devolver en XML debemos hacerlo también explícitamente.&lt;/p>
&lt;p>En ASP.NET Core tenemos a MVC6 que unifica a WebApi y MVC clásico en un solo framework. ¿Como queda el soporte para negociación de contenido en MVC6? Pues bien, existe soporte para ella, pero dependiendo de que IActionResult devolvamos en nuestros controladores. Así, si en WebApi la negociación de contenido se usaba siempre y en MVC clásico nunca, &lt;strong>en MVC6 la negociación de contenido aplica solo si la acción del controlador devuelve un ObjectResult (o derivado)&lt;/strong>. Esto nos permite como desarrolladores decidir sobre qué acciones de qué controladores queremos aplicar la negociación de contenido. Es evidente que aplicarla siempre no tiene sentido: si devolvemos una vista Razor su resultado debe ser sí o sí un HTML que se envía al cliente. No tendría sentido aplicar negociación de contenido sobre una acción que devolviese una vista. De hecho la negociación de contenido tiene sentido en APIs que devuelvan datos (no vistas) y en MVC6 para devolver datos tenemos a ObjectResult, así que es lógico que sea sobre este resultado donde se aplique la negociación de contenido.&lt;/p>
&lt;p>En WebApi la negociación de contenido estaba gestionada por los formateadores (&lt;em>formatters&lt;/em>). Básicamente a cada &lt;em>content-type&lt;/em> se le asociaba un formateador. Si el cliente pedía datos en un determinado content-type se miraba que formateador podía devolver datos en dicho formato. Si no existía se usaba por defecto el formateador de JSON. En MVC6 se ha mantenido básicamente dicho esquema.&lt;/p></description></item></channel></rss>