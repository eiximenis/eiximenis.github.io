<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c# on Lo Cresti√†</title><link>https://www.eiximenis.dev/categories/c#/</link><description>Recent content in c# on Lo Cresti√†</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Mon, 08 Jul 2019 17:43:59 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>Excepciones como errores: ¬øS√≠ o no?</title><link>https://www.eiximenis.dev/posts/2019-07-08-excepciones-como-errores-si-o-no/</link><pubDate>Mon, 08 Jul 2019 17:43:59 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2019-07-08-excepciones-como-errores-si-o-no/</guid><description>&lt;p>Bueno, he aqu√≠ un dilema que es m√°s o menos como el tipado est√°tico vs el din√°mico o el preferir espacios o tabuladores: es decir, preferencia personal. Pero a veces las preferencias personales se ven influenciadas por lo que conocemos (o m√°s precisamente por lo que desconocemos)&amp;hellip; As√≠ que dejadme que os cuente cuatro cosas al respecto y ya si eso, luego lo discutimos en los comentarios o en un bar&amp;hellip;&lt;/p></description></item><item><title>C#9 ‚Äì Type classes y extensiones</title><link>https://www.eiximenis.dev/posts/2019-06-07-c9-type-classes-y-extensiones/</link><pubDate>Fri, 07 Jun 2019 10:58:11 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2019-06-07-c9-type-classes-y-extensiones/</guid><description>&lt;p>Estaba yo revisando &lt;a href="https://github.com/dotnet/csharplang/milestone/15">algunas de las nuevas caracter√≠sticas que quiz√° incorpore C# 9&lt;/a> y me he encontrado con la &lt;a href="https://github.com/dotnet/csharplang/issues/110">propuesta de¬†&lt;strong>type classes&lt;/strong>&lt;/a>¬†(&lt;em>shapes&lt;/em> en la teminolog√≠a de C#), que me parece bastante interesante y sobre la cual me gustar√≠a hacer algunos comentarios üôÇ&lt;/p></description></item><item><title>Comparaciones en C#</title><link>https://www.eiximenis.dev/posts/2018-12-17-comparaciones-en-c/</link><pubDate>Mon, 17 Dec 2018 07:00:28 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-12-17-comparaciones-en-c/</guid><description>&lt;p>¬°Buenas!&lt;/p>
&lt;p>Este¬†&lt;em>post&lt;/em> pertenece al ‚Äú&lt;a href="https://aspnetcoremaster.com/c%23/advientocsharp/2018/11/16/Calendario-adviento-csharp.html">calendario de adviento de C#&lt;/a>‚Äú, y me gustar√≠a hablaros de un tema que parece sencillo pero que bueno, esconde sus cosillas. En concreto sobre¬†&lt;strong>comparaciones en C#&lt;/strong>.&lt;/p></description></item><item><title>C#: Conversiones (expl√≠citas o impl√≠citas) e interfaces</title><link>https://www.eiximenis.dev/posts/2018-12-01-c-conversiones-implicitas-e-interfaces/</link><pubDate>Sat, 01 Dec 2018 15:12:14 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-12-01-c-conversiones-implicitas-e-interfaces/</guid><description>&lt;p>Una de las caracter√≠sticas m√°s √∫tiles, aunque m√°s potencialmente peligrosas de C# es la posibilidad de sobrecargar los operadores de conversi√≥n (&lt;em>casting&lt;/em>) y concretamente el de conversi√≥n impl√≠cita.&lt;/p>
&lt;p>Poder sobrecargar el operador de conversi√≥n expl√≠cita, aunque lo entiendo como una caracter√≠stica que agrega ortogonalidad al lenguaje, no es algo que me guste. Antes de eso prefiero crear un m√©todo AsXXX(). De hecho me parece que un cliente de mi clase encontrar√° m√°s l√≥gico un m√©todo AsXXX() que no ‚Äúun casting a XXX‚Äù que debes saber que se puede hacer para hacerlo.&lt;/p></description></item><item><title>C#: Structs de un solo campo como typedefs</title><link>https://www.eiximenis.dev/posts/2018-11-16-c-structs-de-un-solo-campo-como-typedefs/</link><pubDate>Fri, 16 Nov 2018 09:21:26 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-11-16-c-structs-de-un-solo-campo-como-typedefs/</guid><description>No hace mucho me preguntaba si usar structs de un solo campo ten√≠a alguna penalizaci√≥n respecto a usar, simplemente, una variable del tipo del campo. Es decir, me preguntaba si tener:
struct Sint { public int value; } Ten√≠a alguna penalizaci√≥n al respecto de usar, simplemente, una variable¬†int.
A nivel de memoria sospechaba que no: una struct ocupa lo mismo que la suma de todos sus campos, m√°s los¬†paddings que se agregan para que los campos est√©n alineados, m√°s el¬†padding final que se agrega para que, en el caso de un array, los elementos est√©n alineados.</description></item><item><title>C# Varianza en delegados</title><link>https://www.eiximenis.dev/posts/2018-02-05-c-varianza-en-delegados/</link><pubDate>Mon, 05 Feb 2018 15:02:39 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-02-05-c-varianza-en-delegados/</guid><description>&lt;p>¬°Buenas! A ra√≠z de una situaci√≥n en la que me he encontrado en un proyecto real (de la que luego hablar√©) me he decidido a escribir este post para comentar algunas cosillas sobre varianzas en los delegados mismos.&lt;/p>
&lt;p>Cuando hablamos de varianzas en delegados hay que contemplar dos aspectos:&lt;/p>
&lt;ul>
&lt;li>Varianzas entre los¬†&lt;em>tipos definidos por el delegado&lt;/em> y los¬†&lt;em>tipos de la funci√≥n asignada al delegado&lt;/em>&lt;/li>
&lt;li>Varianzas entre¬†_el tipo del delegado¬†_y otros tipos (en este caso¬†&lt;em>object&lt;/em>).&lt;/li>
&lt;li>Las combinaciones entre esos dos puntos.&lt;/li>
&lt;/ul></description></item><item><title>Marker Interface: ¬øPatr√≥n o Anti-patr√≥n?</title><link>https://www.eiximenis.dev/posts/2018-01-19-marker-interface-patron-o-anti-patron/</link><pubDate>Fri, 19 Jan 2018 13:14:31 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-01-19-marker-interface-patron-o-anti-patron/</guid><description>&lt;p>Llamamos¬†&lt;em>marker interface&lt;/em> a una interfaz vac√≠a. S√≠, s√≠ sin m√©todos ni propiedades ni nada. A pesar de que te pueda parecer una tonter√≠a tiene sus usos. Vamos hablar un poco de este patr√≥n y sus usos y por qu√© es en cierta manera un anti-patr√≥n, aunque no siempre, porque en esa vida, como todo, todo depende&amp;hellip;&lt;/p></description></item><item><title>Hoy he echado en falta poder definir macros en C#</title><link>https://www.eiximenis.dev/posts/2017-12-14-hoy-he-echado-en-falta-poder-definir-macros-en-c/</link><pubDate>Thu, 14 Dec 2017 17:43:12 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2017-12-14-hoy-he-echado-en-falta-poder-definir-macros-en-c/</guid><description>&lt;p>Pues s√≠&amp;hellip; y no me averg√ºenzo de decirlo, si hoy C# tuviese algo como el preprocesador de C/C++ me hubiese hecho feliz.&lt;/p></description></item><item><title>C# 7‚ÄìDefault method implementation?</title><link>https://www.eiximenis.dev/posts/2016-12-21-c-7-default-method-implementation/</link><pubDate>Wed, 21 Dec 2016 11:28:52 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-12-21-c-7-default-method-implementation/</guid><description>&lt;p>El otro d√≠a estuve hablando con &lt;a href="https://twitter.com/jjane90" target="_blank" rel="noopener noreferrer">Joan Jan√©&lt;/a>, sobre la funcionalidad que se &lt;a href="https://github.com/dotnet/roslyn/issues/258" target="_blank" rel="noopener noreferrer">est√° valorando&lt;/a> para C#7 o (probablemente, dado su estado) m√°s adelante. A falta de un nombre mejor llamar√© a esa funcionalidad ‚ÄúDefault method implementation‚Äù porque as√≠ se conoce en Java, donde esa funcionalidad ya existe.&lt;/p>
&lt;p>Joan y yo ten√≠amos puntos de vista totalmente opuestos a dicha caracter√≠stica, mientras que para mi era un a√±adido &lt;strong>muy interesante&lt;/strong> al lenguaje, Joan se alineaba m√°s con las tesis que Fernando Escolar &lt;a href="http://fernandoescolar.github.io/2016/11/16/csharp-7/" target="_blank" rel="noopener noreferrer">expone en un post en su blog&lt;/a>. &lt;strong>Para &lt;a href="https://twitter.com/fernandoescolar" target="_blank" rel="noopener noreferrer">Fer&lt;/a>, esa feature es la peor idea que ha tenido Java en los √∫ltimos a√±os&lt;/strong>. A mi me da la sensaci√≥n que &lt;strong>verlo as√≠ es no entender exactamente que a√±ade esa caracter√≠stica&lt;/strong> y analizarla desde una posici√≥n demasiado r√≠gida. Joan argumentaba problemas relacionados con SOLID, generalmente con el SRP y con la segregaci√≥n de interfaces. En este post voy a comentar lo que, desde mi punto de vista, permitir√≠a esa caracter√≠stica de estar disponible. Y por qu√©, no solo no es una mala idea, si no, a priori, todo lo contrario (tanto en Java como en C# por m√°s que se empecine Fer en decir lo contrario).&lt;/p></description></item><item><title>Algunas consideraciones sobre las structs</title><link>https://www.eiximenis.dev/posts/2016-07-27-algunas-consideraciones-sobre-las-structs/</link><pubDate>Wed, 27 Jul 2016 19:48:11 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-07-27-algunas-consideraciones-sobre-las-structs/</guid><description>&lt;p>El otro d√≠a un tweet de &lt;a href="https://twitter.com/jc_quijano" target="_blank" rel="noopener noreferrer">Juan Quijano&lt;/a>, anim√≥ una peque√±a discusi√≥n sobre la diferencia entre clases y estructuras en .NET. Este no es el primer post que escribo al respecto, pero bueno, aprovechando la coyuntura vamos a comentar algunas de las cosas que se mencionaron en el peque√±o debate que gener√≥ &lt;a href="https://twitter.com/jc_quijano/status/757967853970722817" target="_blank" rel="noopener noreferrer">el tweet de Juan&lt;/a>.&lt;/p></description></item><item><title>C#‚ÄìBuenas pr√°cticas en constructores</title><link>https://www.eiximenis.dev/posts/2016-07-21-cbuenas-prcticas-en-constructores/</link><pubDate>Thu, 21 Jul 2016 07:14:31 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2016-07-21-cbuenas-prcticas-en-constructores/</guid><description>&lt;p>Escribir el constructor de una clase es algo que parece trivial‚Ä¶ A fin de cuentas, el constructor se encarga de construir un objeto, ¬øno? Pero la realidad es que escribir constructores no es tan sencillo como parece. ¬øQu√© significa ‚Äúconstruir‚Äù un objeto? Por supuesto cada clase tendr√° sus propias necesidades, pero hay una serie de gu√≠as y buenas pr√°cticas que nos pueden ayudar a tomar ciertas decisiones. A esto va dedicado este post.&lt;/p></description></item><item><title>Mi carta a los reyes‚Ä¶</title><link>https://www.eiximenis.dev/posts/2008-12-24-mi-carta-a-los-reyes/</link><pubDate>Wed, 24 Dec 2008 13:56:35 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2008-12-24-mi-carta-a-los-reyes/</guid><description>&lt;p>Aunque ser√≠a para unos reyes que pasaran m√°s all√° del 2010, pero bueno‚Ä¶ por pedir que no quede üòõ&lt;/p>
&lt;p>Estas son las cosas que me gustar√≠a que algun dia se incorporasen a C#. Como son fiestas m√°gicas, pues aqu√≠ van para ver si los chicos de Redmond se animan y para alg√∫n milenio las tenemos‚Ä¶&lt;/p></description></item><item><title>Duda metaf√≠sica sobre contravarianza en delegates</title><link>https://www.eiximenis.dev/posts/2008-12-18-duda-metafsica-sobre-contravarianza-en-delegates/</link><pubDate>Thu, 18 Dec 2008 13:14:02 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2008-12-18-duda-metafsica-sobre-contravarianza-en-delegates/</guid><description>&lt;p>Hola‚Ä¶ hoy voy a poner un post sobre una dudilla &lt;em>metaf√≠sica&lt;/em> que me ha surgido, concretamente relativa a los &lt;em>delegates&lt;/em>. Y he pensado‚Ä¶ que mejor sitio que ponerla que aqu√≠??? üòâ&lt;/p>
&lt;p>Los delegates en C# 2.0 son contravariantes, es decir un delegate a un m√©todo que espera un par√°metro tipo X aceptar√° cualquier m√©todo que espere un par√°metro de cualquier tipo base de X.&lt;/p></description></item></channel></rss>