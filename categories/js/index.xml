<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>js on Lo Crestià</title><link>https://www.eiximenis.dev/categories/js/</link><description>Recent content in js on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Tue, 28 Jun 2016 10:00:59 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/js/index.xml" rel="self" type="application/rss+xml"/><item><title>Algunas consideraciones sobre el hoisting</title><link>https://www.eiximenis.dev/posts/2016-06-28-hoisting/</link><pubDate>Tue, 28 Jun 2016 10:00:59 +0000</pubDate><atom:modified>Tue, 28 Jun 2016 10:00:59 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-06-28-hoisting/</guid><description>Mucho se ha escrito sobre el hoisting en JavaScript. Es uno de los conceptos que al principio confunden más. Yo mismo escribí hace ya algún tiempo un post sobre hoisting en el blog de recursos de CampusMvp. Este post pretende entrar en más detalles.
Doy por supuesto que ya sabes que es el hoisting en JavaScript, pero bueno no está de más comentar la definición que es más fácil que te encuentres: el hoisting es básicamente poder acceder a una variable antes de declararla, ya que realmente las declaraciones se mueven al principio del ámbito.</description><dc:creator>eiximenis</dc:creator><category>js</category></item><item><title>Listas "seguras" en JavaScript</title><link>https://www.eiximenis.dev/posts/2016-06-08-listas-seguras-js/</link><pubDate>Wed, 08 Jun 2016 10:00:59 +0000</pubDate><atom:modified>Wed, 08 Jun 2016 10:00:59 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-06-08-listas-seguras-js/</guid><description>Que las clases en ECMASCript 2015 son algo muy diferente a las clases en otros lenguajes como C# o Java, es algo que ya deberíamos tener muy claro. El propio lenguaje funciona de forma muy distinta (dinámico, basado en prototipos, no existen las clases en runtime,&amp;hellip;), pero podemos hacer cosas igualmente interesantes.
Una necesidad que podríamos tener es la de tener una clase que nos permita solo tener objetos de una determinada clase.</description><dc:creator>eiximenis</dc:creator><category>js</category></item><item><title>¿Qué es jspm?</title><link>https://www.eiximenis.dev/posts/2016-05-12-jspm-que-es/</link><pubDate>Thu, 12 May 2016 10:00:59 +0000</pubDate><atom:modified>Thu, 12 May 2016 10:00:59 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-05-12-jspm-que-es/</guid><description>Jspm es otro gestor de paquetes para JavaScript. Por lo tanto antes de nada es lícito preguntarnos&amp;hellip; ¿necesitábamos otro gestor de paquetes?
En JavaScript tenemos al menos dos de dominantes: Por un lado bower, que es (o fue) el gestor de librerías JavaScript de cliente. Es decir, te querías instalar jQuery o Angular? Pues lo instalabas desde Bower. Bower tenía en cuenta las dependencias (p. ej. que Backbone depende de Underscore) y las descargaba automáticamente.</description><dc:creator>eiximenis</dc:creator><category>js</category></item><item><title>Clases como ciudadanos de primer orden en JS</title><link>https://www.eiximenis.dev/posts/2016-03-22-js-clases-primer-orden/</link><pubDate>Tue, 22 Mar 2016 10:00:59 +0000</pubDate><atom:modified>Tue, 22 Mar 2016 10:00:59 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-03-22-js-clases-primer-orden/</guid><description>Una de las novedades de ES2015 es el concepto de clases. Las clases en JavaScript nada tienen que ver con el concepto de &amp;ldquo;clase&amp;rdquo; de otros lenguajes como C++, Java o C#. En JavaScript las clases son una sintaxis alternativa para definir funciones constructoras. Pero, lo que seguimos teniendo por debajo es la herencia entre objetos, basada en prototipos.
Un punto importante, y que se suele pasar por alto, es que dado que una clase al final termina definiendo una función, y las funciones son ciudadanos de primer orden, también deben serlo las clases.</description><dc:creator>eiximenis</dc:creator><category>js</category></item><item><title>Mixins y Traits</title><link>https://www.eiximenis.dev/posts/2016-01-27-mixins/</link><pubDate>Wed, 27 Jan 2016 10:00:59 +0000</pubDate><atom:modified>Wed, 27 Jan 2016 10:00:59 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-01-27-mixins/</guid><description>En este post vamos a ver qué son y en qué consisten los mixins y los traits, dos conceptos muy parecidos entre ellos y que algunas veces se confunden.
Primero comentar que no todos los lenguajes los soportan. P. ej. Java (a partir de la versión 8) permite implementarlos en parte, lo mismo que C# usando métodos de extensión. Otros lenguajes como JavaScript, Swift, C++ o Ruby (entre muchos otros) permiten una implementación más completa, ya sea de forma más o menos directa.</description><dc:creator>eiximenis</dc:creator><category>js</category></item></channel></rss>