<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>netcore on Lo Cresti√†</title><link>https://www.eiximenis.dev/categories/netcore/</link><description>Recent content in netcore on Lo Cresti√†</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Mon, 29 Jun 2020 12:00:00 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/netcore/index.xml" rel="self" type="application/rss+xml"/><item><title>Span&lt;T> y P/Invoke</title><link>https://www.eiximenis.dev/posts/2020-06-29-span_y_pinvoke/</link><pubDate>Mon, 29 Jun 2020 12:00:00 +0000</pubDate><atom:modified>Mon, 29 Jun 2020 12:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-06-29-span_y_pinvoke/</guid><description>Uno de los movimientos m√°s nuevos en .NET Core consiste en lo que podemos llamar &amp;ldquo;zero-allocation code&amp;rdquo; o c√≥digo sin reservas. Eso consiste en tener c√≥digo que evite al m√°ximo (hasta llegar al ideal de eliminar) las reservas de objetos en el heap. Para ello es necesario que tanto el lenguaje como el entorno de ejecuci√≥n lo permitan. Pero&amp;hellip; ¬øpor qu√© es beneficioso evitar las reservas en el heap?
Predictibilidad La raz√≥n principal es la predictibilidad de tu c√≥digo, en este caso predictibilidad en el tiempo de ejecuci√≥n, claro.</description><dc:creator>eiximenis</dc:creator><category>netcore</category></item><item><title>NetCore 3 - NativeLibrary: ¬°p/invoke a tope!</title><link>https://www.eiximenis.dev/posts/2020-01-31-netcore3-nativelibrary/</link><pubDate>Fri, 31 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Fri, 31 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-31-netcore3-nativelibrary/</guid><description>¬øConoces P/Invoke? Se trata de la posibilidad de realizar llamadas nativas al sistema operativo desde c√≥digo .NET. Para habilitarlo debemos definir en C# una funci√≥n externa (usando la palabra clave extern) y luego usar [DllImport] para indicarle al CLR en qu√© librer√≠a del SO se encuentra esta funci√≥n implementada. Por supuesto eso genera c√≥digo que no es cross platform, ya que est√°s llamando expl√≠citamente a una librer√≠a en concreto del SO.</description><dc:creator>eiximenis</dc:creator><category>netcore</category></item><item><title>Admission webhooks de Kubernetes con netcore</title><link>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</link><pubDate>Wed, 29 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Wed, 29 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</guid><description>Si has usado Kubernetes un poco, seguro que conoces el concepto de sidecar container: Un contenedor que se ejecuta en el mismo pod que el contenedor principal y que ofrece servicios adicionales. Es muy habitual en implementaciones de Service Mesh tales como Istio. Tambi√©n dapr se basa en un sidecar as√≠ como Devspaces sin ir m√°s lejos, por poner solo tres ejemplos.
Todo eso viene a cuento, porque cuando usas uno de esos sistemas, tus deployments son modificados autom√°ticamente por el sistema para a√±adir el sidecar container.</description><dc:creator>eiximenis</dc:creator><category>netcore</category><category>k8s</category></item><item><title>WPF y netcore3 con custom host</title><link>https://www.eiximenis.dev/posts/2020-01-20-wpf-netcore3-customhost/</link><pubDate>Mon, 20 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Mon, 20 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-20-wpf-netcore3-customhost/</guid><description>¬°Buf! Hac√≠a un porr√≥n que no escrib√≠a sobre WPF, pero bueno, creo que vale la pena hablar un poco de las ventajas de usar WPF junto con .NET Core 3. S√≠, se habla mucho de los aumentos de rendimiento pero a mi me interesa enfocarlo m√°s en como usar, f√°cilmente, las ventajas intr√≠nsecas de .NET Core al usar un proyecto de WPF. En concreto hay tres puntos que creo que son interesantes: DI, Configuraci√≥n y Logging.</description><dc:creator>eiximenis</dc:creator><category>netcore</category><category>wpf</category></item><item><title>Expediente X en rendimiento</title><link>https://www.eiximenis.dev/posts/2020-01-15-expediente-x-en-rendimiento/</link><pubDate>Wed, 15 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Wed, 15 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-15-expediente-x-en-rendimiento/</guid><description>El expediente es el siguiente: contrariamente a todo sentido com√∫n copiar una estructura de 21 campos double tardaba menos, pero mucho menos, que copiar una clase.
El expediente X Tengo una clase y una estructura equivalentes: simplemente 21 propiedades de tipo double con get y set. Nada m√°s. La clase se llama Point21D y la estructura Point21DStruct.
Luego, tengo dos classes (World21D y World21DStruct) con el mismo c√≥digo salvo, que la primera usa Point21D y la segunda Point21DStruct:</description><dc:creator>eiximenis</dc:creator><category>netcore</category></item><item><title>Terminales y millones de colores: una historia complicada</title><link>https://www.eiximenis.dev/posts/2019-04-05-terminales-y-millones-de-colores-una-historia-complicada/</link><pubDate>Fri, 05 Apr 2019 17:28:27 +0000</pubDate><atom:modified>Fri, 05 Apr 2019 17:28:27 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2019-04-05-terminales-y-millones-de-colores-una-historia-complicada/</guid><description>&lt;p>Los que m√°s o menos me segu√≠s por &lt;a href="https://twitter.com/eiximenis">Twitter&lt;/a>, quiz√° os habr√©is enterado de que estoy escribiendo una &lt;a href="https://github.com/eiximenis/tvision2">librer√≠a¬†&lt;em>cross-platform&lt;/em> (netstandard2) para desarrollar aplicaciones de consola&lt;/a>. Evidentemente &lt;a href="https://github.com/migueldeicaza/gui.cs">no es la √∫nica&lt;/a>, es simplemente otra m√°s y puedo asegurar que me lo paso genial desarroll√°ndola.&lt;/p>
&lt;p>Uno de los objetivos principales cuando empec√©¬†&lt;strong>era permitir usar true color&lt;/strong> (es decir 16 millones de colores) en aquellos terminales que lo soportan y la verdad es que la historia del soporte de colores en terminales da para un post&amp;hellip; y aqu√≠ estamos üòâ&lt;/p></description><dc:creator>eiximenis</dc:creator><category>.net</category><category>consola</category><category>netcore</category></item><item><title>Crear im√°genes Docker de proyectos netcore en varias versiones del framework</title><link>https://www.eiximenis.dev/posts/2018-11-29-crear-imagenes-docker-de-proyectos-netcore-en-varias-versiones-del-framework/</link><pubDate>Thu, 29 Nov 2018 14:33:33 +0000</pubDate><atom:modified>Thu, 29 Nov 2018 14:33:33 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2018-11-29-crear-imagenes-docker-de-proyectos-netcore-en-varias-versiones-del-framework/</guid><description>&lt;p>Imagina que est√°s probando alguna versi√≥n¬†&lt;em>release&lt;/em> de netcore (pongamos la 2.2-preview3) y quieres generar im√°genes Docker de tu proyecto para esa imagen. Pero a la vez quieres tambi√©n crear las im√°genes usando la √∫ltima versi√≥n estable (pongamos la 2.1).&lt;/p>
&lt;p>&lt;strong>Asumiendo que el c√≥digo fuente es compatible&lt;/strong>, ¬øcomo puedes gestionar eso sin morir en el intento?&lt;/p></description><dc:creator>eiximenis</dc:creator><category>docker</category><category>netcore</category></item><item><title>El metapaquete Microsoft.AspNetCore.All</title><link>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</link><pubDate>Tue, 26 Dec 2017 19:47:54 +0000</pubDate><atom:modified>Tue, 26 Dec 2017 19:47:54 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</guid><description>&lt;p>Todos estamos acostumbrados a usar los¬†&lt;strong>paquetes de NuGet en nuestros desarrollos&lt;/strong>. Pero a ra√≠z de Net Core 2.0, apareci√≥ el concepto de¬†&lt;em>metapaquete&lt;/em>. Qu√© es exactamente un¬†&lt;em>metapaquete&lt;/em> y por qu√© existen?&lt;/p>
&lt;p>La respuesta r√°pida es que un¬†&lt;em>metapaquete&lt;/em> de NuGet es simplemente un paquete que¬†&lt;strong>no incluye ning√∫n ensamblado, solo referencia a otros paquetes&lt;/strong>. Es, en definitiva, un mecanismo para ‚Äúagrupar‚Äù paquetes de NuGet bajo un mismo n√∫mero de version.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net core</category><category>netcore</category><category>Sin categor√≠a</category></item><item><title>ASP.NET Core ‚Äì IStartupFilter</title><link>https://www.eiximenis.dev/posts/2017-05-09-asp-net-core-istartupfilter/</link><pubDate>Tue, 09 May 2017 14:55:27 +0000</pubDate><atom:modified>Tue, 09 May 2017 14:55:27 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-05-09-asp-net-core-istartupfilter/</guid><description>&lt;p>Buenas! Vamos a explorar en este post la interfaz &lt;strong>IStartupFilter&lt;/strong>, por lo general un desconocido de ASP.NET Core, pero bueno‚Ä¶ que est√° por ah√≠ y no est√° de m√°s conocerlo un poco. ¬°Vamos all√°!&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category><category>netcore</category></item><item><title>Algunas pinceladas sobre como arquitecturar tu WEB/API</title><link>https://www.eiximenis.dev/posts/2017-04-07-algunas-pinceladas-sobre-como-arquitecturar-tu-webapi/</link><pubDate>Fri, 07 Apr 2017 17:36:32 +0000</pubDate><atom:modified>Fri, 07 Apr 2017 17:36:32 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-04-07-algunas-pinceladas-sobre-como-arquitecturar-tu-webapi/</guid><description>&lt;p>El otro d√≠a &lt;a href="https://twitter.com/antiocol">Ant√≠oco Llanos&lt;/a> lanzaba el &lt;a href="https://twitter.com/antiocol/status/849868562076491776">siguiente tweet&lt;/a>:&lt;/p>
&lt;p>(&lt;em>Siempre las mismas dudas. Que dependa mi capa de negocio de EF para usar sus IDbSet o no&amp;hellip; ¬øabstraer la abstracci√≥n?&lt;/em>)&lt;/p>
&lt;p>Contest√© yo con algunas sugerencias y eso deriv√≥ en otra conversaci√≥n paralela, as√≠ que me parece una buena idea poner &lt;strong>algunas pinceladas&lt;/strong> sobre como podemos abordar ese aspecto. Por supuesto y como digo siempe: &lt;strong>no hay balas de plata&lt;/strong> y &lt;strong>no existe la arquitectura para todo&lt;/strong>. Cada proyecto debe analizarse para valorar la arquitectura a abordar, o arquitecturas porque se pueden usar distintas en un mismo proyecto. As√≠, este post no tiene m√°s pretensi√≥n que contarte algunas ideas, pero las conclusiones que saques de ellas son cosa tuya üòâ&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net vNext</category><category>netcore</category><category>patrones</category></item><item><title>ASP.NET‚ÄìComprueba la disponibilidad de tus servicios</title><link>https://www.eiximenis.dev/posts/2017-03-23-asp-net-comprueba-la-disponibilidad-de-tus-servicios/</link><pubDate>Thu, 23 Mar 2017 15:51:42 +0000</pubDate><atom:modified>Thu, 23 Mar 2017 15:51:42 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-03-23-asp-net-comprueba-la-disponibilidad-de-tus-servicios/</guid><description>&lt;p>Si desarrollas una aplicaci√≥n en ASP.NET y/o ASP.NET Core, te puede interesar una nueva librer√≠a que ha sacado el equipo de .NET: &lt;a href="https://github.com/aspnet/HealthChecks">HealthChecks&lt;/a>. Esa librer√≠a (muy sencilla) contiene lo que necesitas para poder validar que un determinado recurso externo (SQL Server, API remota, etc) est√° funcionando y tambi√©n para que decidas lo que significa que un recurso ‚Äúest√° funcionando‚Äù.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>netcore</category></item></channel></rss>