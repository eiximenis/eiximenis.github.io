<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>k8s on Lo Crestià</title><link>https://www.eiximenis.dev/categories/k8s/</link><description>Recent content in k8s on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Sat, 13 Jun 2020 12:30:00 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>Estableciendo un servidor de DNS propio en AKS</title><link>https://www.eiximenis.dev/posts/2020-06-13-aks-establecer-dns-propio/</link><pubDate>Sat, 13 Jun 2020 12:30:00 +0000</pubDate><atom:modified>Sat, 13 Jun 2020 12:30:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-06-13-aks-establecer-dns-propio/</guid><description>La situación es la siguiente: tienes un AKS y hay determinados dominios que deben servirse usando un servidor de DNS propio, no el que trae &amp;ldquo;AKS por defecto&amp;rdquo;. Claro que&amp;hellip; te has preguntado ¿como funciona la resolución DNS en Kubernetes en general y AKS en particular?
CoreDNS Un servidor de Kubernetes suele incluir un servidor de DNS propio. Técnicamente no es una obligación, pero vamos, es lo habitual y AKS lo incluye de serie, así que lo vamos a dar por supuesto.</description><dc:creator>eiximenis</dc:creator><category>k8s</category></item><item><title>El patrón operador en Kubernetes</title><link>https://www.eiximenis.dev/posts/2020-04-06-el-patron-operador-en-k8s/</link><pubDate>Mon, 06 Apr 2020 12:00:00 +0000</pubDate><atom:modified>Mon, 06 Apr 2020 12:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-04-06-el-patron-operador-en-k8s/</guid><description>Antes de hablar sobre como podemos crear operaadores para Kubernetes, vamos a ver qué entendemos por un operador, para qué lo podemos usar y qué ventajas nos aporta respecto otros mecanismos similares. ¡Vamos allá!
Un operador es un mecanismo para manejar y desplegar aplicaciones para Kubernetes. La palabra clave, aquí es &amp;ldquo;para&amp;rdquo;. No estamos hablando de desplegar una aplicación en un Kubernetes, si no de desplegar una aplicación para Kubernetes. Este &amp;ldquo;para&amp;rdquo; implica, no solo que el despliegue lo efectuamos mediante kubectl si no que también efectuamos el mantenimiento y configuración.</description><dc:creator>eiximenis</dc:creator><category>k8s</category><category>Operadores de Kubernetes</category></item><item><title>Como ejecutar (fácilmente) operator-sdk en Windows</title><link>https://www.eiximenis.dev/posts/2020-03-13-empezando-con-operator-sdk-ejecutando-en-win/</link><pubDate>Fri, 13 Mar 2020 13:00:00 +0000</pubDate><atom:modified>Fri, 13 Mar 2020 13:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-03-13-empezando-con-operator-sdk-ejecutando-en-win/</guid><description>Estoy haciendo una serie de posts (que ya irán saliendo) sobre como crear operadores para Kubernetes. Crear esos operadores implica usar la herramienta operator-sdk que no está disponible para Windows (está solo para MacOS y Linux).
Por supuesto puedes usar una MV Linux y olvidarte de este problema o incluso usar WSL (instalar go, git, kubectl y la CLI de Docker configurada contra el daemon de Docker for Windows), pero si no quieres hacerlo, aquí te propongo una solución con relativa poca fricción: se trata de empaquetar en un contenedor esta aplicación y usar docker para ejecutarla.</description><dc:creator>eiximenis</dc:creator><category>k8s</category><category>Operadores de Kubernetes</category></item><item><title>Ingress, sticky sessions y servicios</title><link>https://www.eiximenis.dev/posts/2020-03-11-ingress-sticky-sessions-y-servicios/</link><pubDate>Wed, 11 Mar 2020 12:00:00 +0000</pubDate><atom:modified>Wed, 11 Mar 2020 12:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-03-11-ingress-sticky-sessions-y-servicios/</guid><description>El otro día estuve revisando un proyecto, desplegado en un Kubernetes (un AKS, aunque eso no es relevante en este caso). El tema es que parecía que &amp;ldquo;las sticky sessions no iban&amp;rdquo;. Por motivos del proyecto, era necesario tener sticky sessions y además estrictas, es decir, que en caso de que se escalara el número de pods los usuarios NO fuesen redirigidos a esos nuevos pods para repartir la carga.</description><dc:creator>eiximenis</dc:creator><category>ingress</category><category>k8s</category></item><item><title>Serverless &amp; Kubernetes</title><link>https://www.eiximenis.dev/posts/2020-02-06-serverless-k8s/</link><pubDate>Thu, 06 Feb 2020 16:30:00 +0000</pubDate><atom:modified>Thu, 06 Feb 2020 16:30:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-02-06-serverless-k8s/</guid><description>Antes de empezar a discutir como Kubernetes y Serverless pueden estar juntos en la misma frase que no sea sacada de un flyer comercial (y por lo tanto, tenga sentido) debemos hablar un poco sobre Serverless en si mismo.
¿Qué es Serverless? El concepto de Serverless significa a grandes rasgos que no &amp;ldquo;ves&amp;rdquo; el servidor que ejecuta tu aplicación. Claro, servidor hay, todavía no se ha inventado el humo que ejecute software, así que en algún lado hay un servidor.</description><dc:creator>eiximenis</dc:creator><category>k8s</category><category>serverless</category></item><item><title>Admission webhooks de Kubernetes con netcore</title><link>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</link><pubDate>Wed, 29 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Wed, 29 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</guid><description>Si has usado Kubernetes un poco, seguro que conoces el concepto de sidecar container: Un contenedor que se ejecuta en el mismo pod que el contenedor principal y que ofrece servicios adicionales. Es muy habitual en implementaciones de Service Mesh tales como Istio. También dapr se basa en un sidecar así como Devspaces sin ir más lejos, por poner solo tres ejemplos.
Todo eso viene a cuento, porque cuando usas uno de esos sistemas, tus deployments son modificados automáticamente por el sistema para añadir el sidecar container.</description><dc:creator>eiximenis</dc:creator><category>netcore</category><category>k8s</category></item></channel></rss>