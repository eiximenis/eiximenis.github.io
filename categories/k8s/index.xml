<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>k8s on Lo Crestià</title><link>https://www.eiximenis.dev/categories/k8s/</link><description>Recent content in k8s on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Fri, 13 Mar 2020 13:00:00 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>Como ejecutar (fácilmente) operator-sdk en Windows</title><link>https://www.eiximenis.dev/posts/2020-03-13-empezando-con-operator-sdk-ejecutando-en-win/</link><pubDate>Fri, 13 Mar 2020 13:00:00 +0000</pubDate><atom:modified>Fri, 13 Mar 2020 13:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-03-13-empezando-con-operator-sdk-ejecutando-en-win/</guid><description>Estoy haciendo una serie de posts (que ya irán saliendo) sobre como crear operadores para Kubernetes. Crear esos operadores implica usar la herramienta operator-sdk que no está disponible para Windows (está solo para MacOS y Linux).
Por supuesto puedes usar una MV Linux y olvidarte de este problema o incluso usar WSL (instalar go, git, kubectl y la CLI de Docker configurada contra el daemon de Docker for Windows), pero si no quieres hacerlo, aquí te propongo una solución con relativa poca fricción: se trata de empaquetar en un contenedor esta aplicación y usar docker para ejecutarla.</description><dc:creator>eiximenis</dc:creator><category>k8s</category><category>Operadores de Kubernetes</category></item><item><title>Ingress, sticky sessions y servicios</title><link>https://www.eiximenis.dev/posts/2020-03-11-ingress-sticky-sessions-y-servicios/</link><pubDate>Wed, 11 Mar 2020 12:00:00 +0000</pubDate><atom:modified>Wed, 11 Mar 2020 12:00:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-03-11-ingress-sticky-sessions-y-servicios/</guid><description>El otro día estuve revisando un proyecto, desplegado en un Kubernetes (un AKS, aunque eso no es relevante en este caso). El tema es que parecía que &amp;ldquo;las sticky sessions no iban&amp;rdquo;. Por motivos del proyecto, era necesario tener sticky sessions y además estrictas, es decir, que en caso de que se escalara el número de pods los usuarios NO fuesen redirigidos a esos nuevos pods para repartir la carga.</description><dc:creator>eiximenis</dc:creator><category>ingress</category><category>k8s</category></item><item><title>Serverless &amp; Kubernetes</title><link>https://www.eiximenis.dev/posts/2020-02-06-serverless-k8s/</link><pubDate>Thu, 06 Feb 2020 16:30:00 +0000</pubDate><atom:modified>Thu, 06 Feb 2020 16:30:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-02-06-serverless-k8s/</guid><description>Antes de empezar a discutir como Kubernetes y Serverless pueden estar juntos en la misma frase que no sea sacada de un flyer comercial (y por lo tanto, tenga sentido) debemos hablar un poco sobre Serverless en si mismo.
¿Qué es Serverless? El concepto de Serverless significa a grandes rasgos que no &amp;ldquo;ves&amp;rdquo; el servidor que ejecuta tu aplicación. Claro, servidor hay, todavía no se ha inventado el humo que ejecute software, así que en algún lado hay un servidor.</description><dc:creator>eiximenis</dc:creator><category>k8s</category><category>serverless</category></item><item><title>Admission webhooks de Kubernetes con netcore</title><link>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</link><pubDate>Wed, 29 Jan 2020 18:20:00 +0000</pubDate><atom:modified>Wed, 29 Jan 2020 18:20:00 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2020-01-29-admission-webhooks-de-k8s-en-netcore/</guid><description>Si has usado Kubernetes un poco, seguro que conoces el concepto de sidecar container: Un contenedor que se ejecuta en el mismo pod que el contenedor principal y que ofrece servicios adicionales. Es muy habitual en implementaciones de Service Mesh tales como Istio. También dapr se basa en un sidecar así como Devspaces sin ir más lejos, por poner solo tres ejemplos.
Todo eso viene a cuento, porque cuando usas uno de esos sistemas, tus deployments son modificados automáticamente por el sistema para añadir el sidecar container.</description><dc:creator>eiximenis</dc:creator><category>netcore</category><category>k8s</category></item><item><title>Introducción a KEDA</title><link>https://www.eiximenis.dev/posts/2020-03-04-inroduccion-a-keda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2020-03-04-inroduccion-a-keda/</guid><description>KEDA significa Kubernetes Event Driven Autoscaler y es un proyecto iniciado por Microsoft y Red Hat para facilitar el uso de workloads serverless ejecutándose en Kubernetes.
Serverless en Kubernetes SIN Keda El problema no es ejecutar workloads serverless (FaaS para ser más concretos): A fin de cuentas si puedes crear una imagen Docker de tu FaaS la puedes desplegar en Kubernetes y este la va a ejecutar. Vamos a ver un ejemplo usando Azure Functions, aunque más adelante en esta serie hablaremos de OpenFaas y AWS Lambda entre otras.</description><dc:creator>eiximenis</dc:creator><category>Keda</category><category>k8s</category><category>serverless</category></item></channel></rss>