<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sin categoría on Lo Crestià</title><link>https://www.eiximenis.dev/categories/sin-categor%C3%ADa/</link><description>Recent content in Sin categoría on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Fri, 28 Dec 2018 14:51:23 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/sin-categor%C3%ADa/index.xml" rel="self" type="application/rss+xml"/><item><title>Ya es oficial: Microsoft anuncia el abandono de Full Framework</title><link>https://www.eiximenis.dev/posts/2018-12-28-ya-es-oficial-microsoft-anuncia-el-abandono-de-full-framework/</link><pubDate>Fri, 28 Dec 2018 14:51:23 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-12-28-ya-es-oficial-microsoft-anuncia-el-abandono-de-full-framework/</guid><description>&lt;p>A ver, era algo que se veía a venir&amp;hellip; Microsoft ha anunciado finalmente el abandono de Full Framework, en favor de Net Core. Cualquiera que estuviese al tanto de los intríngulis de pasillo del gigante de Redmond sabía que ambos equipos andaban bastante a la greña.&lt;/p></description></item><item><title>SF Mesh: Primeras impresiones</title><link>https://www.eiximenis.dev/posts/2018-07-18-sf-mesh-primeras-impresiones/</link><pubDate>Wed, 18 Jul 2018 14:39:20 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-07-18-sf-mesh-primeras-impresiones/</guid><description>&lt;p>Dentro de esta vorágine de productos relacionados con los contenedores en la que está inmersa Microsoft, ahora le toca el turno a &lt;a href="https://azure.microsoft.com/en-us/blog/azure-service-fabric-mesh-is-now-in-public-preview/">Service Fabric Mesh que salió hace nada en public preview&lt;/a>. En este post quiero comentaros un poco de qué va este producto y como ha ido mi (limitada) experiencia con él.&lt;/p>
&lt;p>&lt;strong>Disclaimer:&lt;/strong> Este es un post sobre un producto que está en &lt;em>preview&lt;/em>. Lo expuesto aquí puede cambiar a medida que avance tanto el propio producto como mi experiencia en él.&lt;/p></description></item><item><title>Añadir soporte TLS a tu Kubernetes en Azure con Let's Encrypt</title><link>https://www.eiximenis.dev/posts/2018-04-13-anadir-soporte-tls-a-tu-kubernetes-en-azure-con-lets-encrypt/</link><pubDate>Fri, 13 Apr 2018 16:05:06 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-04-13-anadir-soporte-tls-a-tu-kubernetes-en-azure-con-lets-encrypt/</guid><description>&lt;p>¡Buenas! En este post vamos a ver como añadir soporte TLS a tu clúster de Kubernetes desplegado en ACS o AKS. Hace tiempo escribí un post sobre como añadir certificados de desarrollo a un servicio NGINX que tuvieses en Kubernetes. Aunque lo dicho en [aquel post][1] sigue siendo válido, hay una manera mucho más sencilla con la condición de que [usemos &lt;em>ingress&lt;/em> para exponer nuestros servicios al exterior][2].&lt;/p>
&lt;p>En este post parto de la suposición de que:&lt;/p>
&lt;ol>
&lt;li>Tienes un clúster de Kubernetes en ACS/AKS y &lt;em>kubectl&lt;/em> configurado para atacar a él&lt;/li>
&lt;li>Tienes el controlador &lt;em>ingress&lt;/em> de NGINX instalado en el clúster exponiendo cualquier servicio&lt;/li>
&lt;/ol>
&lt;p>Es decir, haciendo http://IP-CLUSTER/servicio obtienes alguna respuesta. Lo que queremos es poder usar https en su lugar.&lt;/p></description></item><item><title>Ejecutar pruebas de tus contenedores en VSTS</title><link>https://www.eiximenis.dev/posts/2018-03-07-ejecutar-pruebas-de-tus-contenedores-en-vsts/</link><pubDate>Wed, 07 Mar 2018 12:33:37 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-03-07-ejecutar-pruebas-de-tus-contenedores-en-vsts/</guid><description>&lt;p>Si desarrollas con Docker es probable que uses &lt;a href="https://geeks.ms/etomas/2017/11/28/docker-multi-stage-builds-o-como-compilar-casi-cualquier-cosa-sin-tener-que-instalar-nada/">&lt;em>multi-stage builds&lt;/em>&lt;/a> para crear tus contenedores, en este caso unificas bajo un mismo Dockerfile la creación del binario (usando una imagen de compilación) y la creación de la imagen final (basandote en una imagen de &lt;em>runtime&lt;/em>).&lt;/p>
&lt;p>Ahora bien, si usas un pipeline de CI/CD con VSTS&amp;hellip; ¿como gestionar los tests de esos contenedores? Eso es lo que vamos a discutir en este post.&lt;/p></description></item><item><title>Dependencias condicionales en VS</title><link>https://www.eiximenis.dev/posts/2018-01-22-dependencias-condicionales-en-vs/</link><pubDate>Mon, 22 Jan 2018 16:28:19 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-01-22-dependencias-condicionales-en-vs/</guid><description>&lt;p>Bueno, imagina que trabajas en un proyecto en NetCore que debe ser multiplataforma. En general el propio framework te provee de todo lo necesario, pero sigamos imaginando que algunas partes de tu proyecto dependen via P/Invoke de llamadas nativas.&lt;/p>
&lt;p>En este caso puedes optar por tener todos los enlaces P/Invoke para cada plataforma en el mismo proyecto (no hay ningún problema) o bien tenerlos separados en proyectos por cada una de las plataformas.&lt;/p></description></item><item><title>Kubernetes (3) – Controladores Ingress</title><link>https://www.eiximenis.dev/posts/2018-01-03-kubernetes-3-controladores-ingress/</link><pubDate>Wed, 03 Jan 2018 16:48:58 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2018-01-03-kubernetes-3-controladores-ingress/</guid><description>&lt;p>Seguimos con esta serie de posts sobre Kubernetes. Los posts anteriores:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://geeks.ms/etomas/2017/12/19/kubernetes-1-componentes-de-kubernetes/">Componentes de Kubernetes&lt;/a> (donde vimos los distintos componentes de Kubernetes y como usar &lt;a href="https://github.com/kubernetes/minikube">Minikube&lt;/a> para ejecutarlo en local).&lt;/li>
&lt;li>&lt;a href="https://geeks.ms/etomas/2017/12/21/kubernetes-2-modelo-de-aplicacion/">Modelo de aplicación&lt;/a> (donde vimos como crear nuestra primera aplicación en k8s).&lt;/li>
&lt;/ol>
&lt;p>En este tercer post veremos que son los recursos &lt;em>ingress&lt;/em> y los controladores &lt;em>ingress&lt;/em> y que ventajas nos aportan.&lt;/p></description></item><item><title>El metapaquete Microsoft.AspNetCore.All</title><link>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</link><pubDate>Tue, 26 Dec 2017 19:47:54 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</guid><description>&lt;p>Todos estamos acostumbrados a usar los &lt;strong>paquetes de NuGet en nuestros desarrollos&lt;/strong>. Pero a raíz de Net Core 2.0, apareció el concepto de &lt;em>metapaquete&lt;/em>. Qué es exactamente un &lt;em>metapaquete&lt;/em> y por qué existen?&lt;/p>
&lt;p>La respuesta rápida es que un &lt;em>metapaquete&lt;/em> de NuGet es simplemente un paquete que &lt;strong>no incluye ningún ensamblado, solo referencia a otros paquetes&lt;/strong>. Es, en definitiva, un mecanismo para “agrupar” paquetes de NuGet bajo un mismo número de version.&lt;/p></description></item><item><title>Kubernetes (2) – Modelo de aplicación</title><link>https://www.eiximenis.dev/posts/2017-12-21-kubernetes-2-modelo-de-aplicacion/</link><pubDate>Thu, 21 Dec 2017 11:18:03 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2017-12-21-kubernetes-2-modelo-de-aplicacion/</guid><description>&lt;p>Si conoces compose conocerás su “modelo de aplicación”. Es un modelo sencillo, contiene básicamente &lt;em>servicios.&lt;/em> Un servicio en compose no es nada más que una imagen de Docker y su configuración asociada.  Luego cuando levantamos una aplicación compose con &lt;code>docker-compose up&lt;/code> se crea uno (o varios) contenedor por cada servicio y listos.&lt;/p>
&lt;p>Pero Kubernetes tiene su propio modelo de aplicación radicalmente distinto. En este post vamos a ver (de forma simplificada) cual es el modelo de aplicación que tiene Kubernetes y ¡desplegaremos nuestra primera aplicación!&lt;/p></description></item><item><title>Docker multi-stage builds… o como compilar (casi) cualquier cosa sin tener que instalar nada.</title><link>https://www.eiximenis.dev/posts/2017-11-28-docker-multi-stage-builds-o-como-compilar-casi-cualquier-cosa-sin-tener-que-instalar-nada/</link><pubDate>Tue, 28 Nov 2017 12:58:09 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2017-11-28-docker-multi-stage-builds-o-como-compilar-casi-cualquier-cosa-sin-tener-que-instalar-nada/</guid><description>&lt;p>Poco a poco los contenedores, y Docker en especial, se han ido abriendo paso en nuestro &lt;em>workflow&lt;/em> diario. Y si al principio era tan solo un mecanismo para encapsular aplicaciones, luego también vimos en ellos una magnífica opción para evitar tener que instalar mil dependencias en las máquinas de desarrollo y finalmente para compilar cualquier proyecto&amp;hellip; sin tener que instalar ningún SDK en local.&lt;/p></description></item><item><title>Configurar SSL en un cluster de k8s</title><link>https://www.eiximenis.dev/posts/2017-10-16-configurar-ssl-en-un-cluster-de-k8s/</link><pubDate>Mon, 16 Oct 2017 14:38:27 +0000</pubDate><guid>https://www.eiximenis.dev/posts/2017-10-16-configurar-ssl-en-un-cluster-de-k8s/</guid><description>&lt;p>¡Buenas! En esta entrada voy a resumir los pasos seguidos para añadir soporte SSL a un cluster Kubernetes. En mi caso lo tengo desplgado en ACS pero eso es irrelevante.&lt;/p>
&lt;p>Lo único que si usas ACS y quieres usar una IP determinada, recuerda que la IP pública que vayas a usar debe estar creada anteriormente. Si no, por más que la especifiques dentro de la configuración del servicio (usando &lt;em>loadBalancerIP&lt;/em>), Kubernetes no va a poder levantar el servicio.&lt;/p></description></item></channel></rss>