<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>asp.net 5 on Lo Crestià</title><link>https://www.eiximenis.dev/categories/asp.net-5/</link><description>Recent content in asp.net 5 on Lo Crestià</description><generator>Hugo -- gohugo.io</generator><language>es</language><copyright>{}</copyright><lastBuildDate>Thu, 07 Jun 2018 11:04:55 +0000</lastBuildDate><atom:link href="https://www.eiximenis.dev/categories/asp.net-5/index.xml" rel="self" type="application/rss+xml"/><item><title>Novedades .NET Core 2.1: Generic host</title><link>https://www.eiximenis.dev/posts/2018-06-07-novedades-net-core-2-1-generic-host/</link><pubDate>Thu, 07 Jun 2018 11:04:55 +0000</pubDate><atom:modified>Thu, 07 Jun 2018 11:04:55 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2018-06-07-novedades-net-core-2-1-generic-host/</guid><description>&lt;p>Ahora que .NET Core 2.1 ya es oficial ya podemos desgranar algunas de sus novedades más interesantes. La verdad es que, por fin, se vislumbra una madurez en la plataforma. Realmente a no ser que haya algún motivo de fuerza mayor (librería no disponible), .NET Core 2.1 debería ser la opción &lt;em>por defecto&lt;/em> a la hora de empezar cualquier proyecto nuevo.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>.net</category><category>asp.net 5</category></item><item><title>El metapaquete Microsoft.AspNetCore.All</title><link>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</link><pubDate>Tue, 26 Dec 2017 19:47:54 +0000</pubDate><atom:modified>Tue, 26 Dec 2017 19:47:54 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-12-26-el-metapaquete-microsoft-aspnetcore-all/</guid><description>&lt;p>Todos estamos acostumbrados a usar los &lt;strong>paquetes de NuGet en nuestros desarrollos&lt;/strong>. Pero a raíz de Net Core 2.0, apareció el concepto de &lt;em>metapaquete&lt;/em>. Qué es exactamente un &lt;em>metapaquete&lt;/em> y por qué existen?&lt;/p>
&lt;p>La respuesta rápida es que un &lt;em>metapaquete&lt;/em> de NuGet es simplemente un paquete que &lt;strong>no incluye ningún ensamblado, solo referencia a otros paquetes&lt;/strong>. Es, en definitiva, un mecanismo para “agrupar” paquetes de NuGet bajo un mismo número de version.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net core</category><category>netcore</category><category>Sin categoría</category></item><item><title>ASP.NET Core 2–Razor Pages</title><link>https://www.eiximenis.dev/posts/2017-05-25-asp-net-core-2-razor-pages/</link><pubDate>Thu, 25 May 2017 10:14:41 +0000</pubDate><atom:modified>Thu, 25 May 2017 10:14:41 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-05-25-asp-net-core-2-razor-pages/</guid><description>&lt;p>&lt;strong>Nota: Este post es sobre ASP.NET Core 2 Preview 1. Algunas cosas pueden cambiar en la versión final.&lt;/strong>&lt;/p>
&lt;p>¿Quien se acuerda de las ASP.NET Web Pages? Salieron tampoco hace tanto, más o menos junto con MVC3 y les acompañaba un producto propio (WebMatrix). Su objetivo era proporcionar un modelo de desarrollo basado en páginas (a lo Webforms) en contraposición del modelo basado en controladores de MVC.&lt;/p>
&lt;p>He de reconocer que nunca les presté mucha atención y tengo la impresión que el resto del mundo tampoco. Su objetivo creo que era ofrecer una puerta de entrada rápida a ASP.NET ofreciendo un modelo sencillo de páginas. Su principal problema es que era difícil integrarlo en un proyecto “más grande” que estuviese hecho en ASP.NET MVC y así tener partes usando “Web Pages” y otras en MVC. Y, honestamente, montar un proyecto complejo en un modelo basado en páginas, no termino de verlo.&lt;/p>
&lt;p>Personalmente las olvidé hace tiempo y por eso el anuncio de “Razor Pages” en ASP.NET Core 2 me sorprendió bastante. Pero la realidad es que Razor Pages es otra cosa bastante más interesante que las antiguas “Web Pages”…&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net core</category></item><item><title>ASP.NET Core – IStartupFilter</title><link>https://www.eiximenis.dev/posts/2017-05-09-asp-net-core-istartupfilter/</link><pubDate>Tue, 09 May 2017 14:55:27 +0000</pubDate><atom:modified>Tue, 09 May 2017 14:55:27 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2017-05-09-asp-net-core-istartupfilter/</guid><description>&lt;p>Buenas! Vamos a explorar en este post la interfaz &lt;strong>IStartupFilter&lt;/strong>, por lo general un desconocido de ASP.NET Core, pero bueno… que está por ahí y no está de más conocerlo un poco. ¡Vamos allá!&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category><category>netcore</category></item><item><title>Docker para el desarrollador de asp.net (iii)</title><link>https://www.eiximenis.dev/posts/2016-11-24-docker-para-el-desarrollador-de-asp-net-iii/</link><pubDate>Thu, 24 Nov 2016 09:27:48 +0000</pubDate><atom:modified>Thu, 24 Nov 2016 09:27:48 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-11-24-docker-para-el-desarrollador-de-asp-net-iii/</guid><description>&lt;p>En el &lt;a href="http://geeks.ms/etomas/2016/11/22/docker-para-el-desarrollador-asp-net-ii/" target="_blank" rel="noopener noreferrer">post anterior&lt;/a> vimos como empaquetar y desplegar en Docker una sencilla aplicación (un &lt;em>hello world&lt;/em>) en asp.net core. En este post vamos a ver como desplegar en Docker una aplicación asp.net core (con sus controladores y vistas) y también ver como lo podemos usar usando una imagen base que no tenga el SDK, solo el runtime.&lt;/p>
&lt;p>¡Vamos allá!&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category><category>docker</category></item><item><title>Docker para el desarrollador asp.net (ii)</title><link>https://www.eiximenis.dev/posts/2016-11-22-docker-para-el-desarrollador-asp-net-ii/</link><pubDate>Tue, 22 Nov 2016 12:30:46 +0000</pubDate><atom:modified>Tue, 22 Nov 2016 12:30:46 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-11-22-docker-para-el-desarrollador-asp-net-ii/</guid><description>&lt;p>Seguimos con esta sobre el uso de Docker desde el punto de vista de un desarrollador asp.net (core). En este caso &lt;strong>vamos a construir nuestra primera imagen Docker&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Nota:&lt;/strong> Visual Studio 2017 incorpora de serie las &lt;em>Docker Tools&lt;/em> que automatizan todo lo que veremos en estos artículos. Tiempo tendremos, más adelante en esta serie, de hablar de las &lt;em>Docker Tools&lt;/em>. La razón de hacerlo primero todo “manual” es porque el objetivo de esta serie es ayudarte a que entiendas Docker, no presentarte el “botón mágico” que se encarga de todo. Yo, es que soy de la vieja escuela: me gusta entender las cosas (al menos hasta donde puedo).&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category><category>docker</category></item><item><title>Docker para el desarrollador asp.net (i)</title><link>https://www.eiximenis.dev/posts/2016-11-21-docker-para-el-desarrollador-asp-net-i/</link><pubDate>Mon, 21 Nov 2016 10:52:01 +0000</pubDate><atom:modified>Mon, 21 Nov 2016 10:52:01 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-11-21-docker-para-el-desarrollador-asp-net-i/</guid><description>&lt;p>Buenas! Vamos a &lt;strong>empezar una serie de posts&lt;/strong> dedicadas a &lt;em>Docker&lt;/em> desde el punto de vista de un desarrollador asp.net. &lt;strong>Empezaremos por lo más básico pero nos iremos adentrando un poco en el mundo de Docker&lt;/strong>. El objetivo es que terminemos teniendo unos conocimientos &lt;em>medios&lt;/em> que nos permitan entender que es Docker, como funciona, qué ventajas tiene y como usarlo (y cuando) en arquitecturas más complejas donde haya más de un contenedor. Pero… &lt;strong>empecemos por el principio&lt;/strong>.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category><category>docker</category></item><item><title>MVC6–Recibir un GUID en el cuerpo de la petición</title><link>https://www.eiximenis.dev/posts/2016-09-30-mvc6recibir-un-guid-en-el-cuerpo-de-la-peticin/</link><pubDate>Fri, 30 Sep 2016 10:08:23 +0000</pubDate><atom:modified>Fri, 30 Sep 2016 10:08:23 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-09-30-mvc6recibir-un-guid-en-el-cuerpo-de-la-peticin/</guid><description>&lt;p>Hoy me he encontrado un &lt;strong>controlador MVC6&lt;/strong> con la siguiente acción:&lt;/p>
&lt;pre style="max-width: 700px; font-family: consolas; background: #1e1e1e; white-space: nowrap; overflow-x: scroll; color: gainsboro">[&lt;span style="color: #4ec9b0">HttpPut&lt;/span>]&lt;br />[&lt;span style="color: #4ec9b0">Route&lt;/span>(&lt;span style="color: #d69d85">"{userid:int}/faceprofile"&lt;/span>)]&lt;br />&lt;span style="color: #569cd6">public&lt;/span>&amp;nbsp;&lt;span style="color: #569cd6">async&lt;/span>&amp;nbsp;&lt;span style="color: #4ec9b0">Task&lt;/span>&amp;lt;&lt;span style="color: #b8d7a3">IActionResult&lt;/span>&amp;gt; SetFaceProfileId(&lt;span style="color: #569cd6">int&lt;/span> userid, [&lt;span style="color: #4ec9b0">FromBody&lt;/span>] &lt;span style="color: #4ec9b0">Guid&lt;/span> id)&lt;/pre>
&lt;p>Claramente su autor esperaba que pudieramos poner un Guid en el cuerpo de la petición y eso funcionaría… Pero, ¿como debe mandarse?&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category></item><item><title>Creando formateadores de salida en asp.net core</title><link>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</link><pubDate>Thu, 21 Apr 2016 07:51:29 +0000</pubDate><atom:modified>Thu, 21 Apr 2016 07:51:29 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-04-21-creando-formateadores-de-salida-en-asp-net-core/</guid><description>&lt;p>Cuando salió WebApi lo hizo con la negociación de contenido incorporada de serie en el framework. Eso venía a significar, básicamente, que el framework intentaba suministrar los datos en el formato en que el cliente los había pedido. La negociación de contenido se basa (generalmente) en el uso de la cabecera &lt;em>accept&lt;/em> de HTTP: el cliente manda en esa cabecera cual, o cuales, son sus formatos de respuesta preferidos. WebApi soporta de serie devolver datos en JSON y XML y el sistema es extensible para crear nuestros propios formatos.&lt;/p>
&lt;p>“MVC clásico” (es decir hasta MVC5) no incluye soporte de negociación de contenido: en MVC si queremos devolver datos en formato JSON, debemos devolver explícitamente un JsonResult y si los queremos devolver en XML debemos hacerlo también explícitamente.&lt;/p>
&lt;p>En ASP.NET Core tenemos a MVC6 que unifica a WebApi y MVC clásico en un solo framework. ¿Como queda el soporte para negociación de contenido en MVC6? Pues bien, existe soporte para ella, pero dependiendo de que IActionResult devolvamos en nuestros controladores. Así, si en WebApi la negociación de contenido se usaba siempre y en MVC clásico nunca, &lt;strong>en MVC6 la negociación de contenido aplica solo si la acción del controlador devuelve un ObjectResult (o derivado)&lt;/strong>. Esto nos permite como desarrolladores decidir sobre qué acciones de qué controladores queremos aplicar la negociación de contenido. Es evidente que aplicarla siempre no tiene sentido: si devolvemos una vista Razor su resultado debe ser sí o sí un HTML que se envía al cliente. No tendría sentido aplicar negociación de contenido sobre una acción que devolviese una vista. De hecho la negociación de contenido tiene sentido en APIs que devuelvan datos (no vistas) y en MVC6 para devolver datos tenemos a ObjectResult, así que es lógico que sea sobre este resultado donde se aplique la negociación de contenido.&lt;/p>
&lt;p>En WebApi la negociación de contenido estaba gestionada por los formateadores (&lt;em>formatters&lt;/em>). Básicamente a cada &lt;em>content-type&lt;/em> se le asociaba un formateador. Si el cliente pedía datos en un determinado content-type se miraba que formateador podía devolver datos en dicho formato. Si no existía se usaba por defecto el formateador de JSON. En MVC6 se ha mantenido básicamente dicho esquema.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net MVC</category></item><item><title>Middlewares de autenticación en asp.net core</title><link>https://www.eiximenis.dev/posts/2016-04-19-middlewares-de-autenticacin-en-asp-net-core/</link><pubDate>Tue, 19 Apr 2016 10:25:32 +0000</pubDate><atom:modified>Tue, 19 Apr 2016 10:25:32 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-04-19-middlewares-de-autenticacin-en-asp-net-core/</guid><description>&lt;p>La autenticación y autorización de peticiones es una de las funcionalidades que más quebraderos da en el desarrollo de aplicaciones en ASP.NET. Además es que ha ido cambiando con el tiempo… En un escenario de internet, en ASP.NET clásico, ya fuese Webforms o MVC usábamos FormsAuthentication. Por otra parte cuando apareció WebApi, incorporó sus propios mecanismos de autenticación y autorización, generalmente basados en la implementación de MessageHandlers.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category></item><item><title>Autenticación por AAD en ASP.NET Core</title><link>https://www.eiximenis.dev/posts/2016-04-07-autenticacin-por-aad-en-asp-net-core/</link><pubDate>Thu, 07 Apr 2016 16:33:41 +0000</pubDate><atom:modified>Thu, 07 Apr 2016 16:33:41 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-04-07-autenticacin-por-aad-en-asp-net-core/</guid><description>&lt;p>Este es un &lt;strong>post introductorio, de una serie de posts&lt;/strong>, donde veremos como podemos integrar ASP.NET Core y &lt;em>Azure Active Directory&lt;/em> (AAD). En este primer escenario el objetivo es tener una aplicación web, donde se requiera hacer login contra AAD para autenticarse.&lt;/p>
&lt;p>&lt;strong>Nota:&lt;/strong> El post está basado en la RC1 de ASP.NET Core… Lo digo porque bueno, a saber que &lt;span style="text-decoration: line-through;">romperán&lt;/span> mejorarán en futuras versiones, pues igual algo cambia 🙂&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category></item><item><title>Creating middlewares de asp.net core</title><link>https://www.eiximenis.dev/posts/2016-02-29-creating-middlewares-de-asp-net-core/</link><pubDate>Mon, 29 Feb 2016 17:08:12 +0000</pubDate><atom:modified>Mon, 29 Feb 2016 17:08:12 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-02-29-creating-middlewares-de-asp-net-core/</guid><description>&lt;p>Asp.net core se basa en el concepto de &lt;strong>middleware&lt;/strong>. En este modelo la petición web viaja a través de un conjunto de componentes. Cada componente recibe la petición y puede:&lt;/p>
&lt;ol>
&lt;li>Modificar la petición &lt;strong>y enviarla al siguiente componente&lt;/strong>&lt;/li>
&lt;li>O bien, generar una respuesta &lt;strong>y enviarla de vuelta al componente anterior&lt;/strong>.&lt;/li>
&lt;/ol></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category></item><item><title>Routers en asp.net core</title><link>https://www.eiximenis.dev/posts/2016-02-26-routers-en-asp-net-core/</link><pubDate>Fri, 26 Feb 2016 11:47:29 +0000</pubDate><atom:modified>Fri, 26 Feb 2016 11:47:29 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2016-02-26-routers-en-asp-net-core/</guid><description>&lt;p>Cuando hablamos del &lt;em>routing&lt;/em> solemos referirnos al proceso por el cual una petición es enrutada hacia una acción concreta de un controlador. Esa definición es cierta en el contexto de una aplicación ASP.NET MVC (y/o WebApi) pero en ASP.NET Core, el concepto de routing es una parte integral del framework.&lt;/p>
&lt;p>Por ello, en ASP.NET Core entendemos el routing como el proceso mediante el cual una petición web es enrutada hacia donde tenga que ser tratada. El destino puede ser una acción de un controlador, pero no tiene por qué (el middleware de MVC6 podría no estar instalado en el pipeline de la aplicación). En este post vamos a ver como funciona este proceso de enrutado.&lt;/p></description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category><category>asp.net vNext</category></item><item><title>Como depurar fácilmente el código de ASP.NET5</title><link>https://www.eiximenis.dev/posts/2015-11-11-como-depurar-fcilmente-el-cdigo-de-asp-net5/</link><pubDate>Wed, 11 Nov 2015 10:09:55 +0000</pubDate><atom:modified>Wed, 11 Nov 2015 10:09:55 +0000</atom:modified><guid>https://www.eiximenis.dev/posts/2015-11-11-como-depurar-fcilmente-el-cdigo-de-asp-net5/</guid><description>¡Muy buenas! Para los que andamos trasteando con versiones alfas y betas con nula o poca documentación, poder depurar el código fuente de las librerías es una manera muy buena de ver qué hace y como lo hace. Cierto, solo leyendo el código fuente se puede aprender mucho, pero poder depurarlo paso a paso es todavía más útil.
El primer paso es, por supuesto, disponer del código fuente. En según que librerías eso no es posible, aunque siempre se podía tirar de los desensambladores (por más que eso pueda no ser legal).</description><dc:creator>eiximenis</dc:creator><category>asp.net 5</category></item></channel></rss>