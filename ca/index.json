[{"content":"Si tens experiència amb Entity Framework, probablament aquesta entrada tampoc t\u0026rsquo;aportarà massa, però després de veure els mateixos errors en varis projectes, mira tu\u0026hellip; m\u0026rsquo;he decidit a escriure-la. I va de com assegurar-te de que totes les teves consultes LINQ (usant EF) s\u0026rsquo;executin a la BBDD.\nAvaluació en client Les primeres versions d\u0026rsquo;EF (fins la 3.0, aquesta ja exclosa) tenien la possibilitat de realitzar el que s\u0026rsquo;anomenava \u0026ldquo;avaluació en client\u0026rdquo;. Però recordem primer el què fa EF: ha de traduir un arbre d\u0026rsquo;expressió a una sentència SQL. Un arbre d\u0026rsquo;expressió en C# és una instància de la classe Expression\u0026lt;T\u0026gt; a on el tipus T és un delegat. P. ex. Expression\u0026lt;Func\u0026lt;int, bool\u0026gt;\u0026gt; sería un arbre d\u0026rsquo;expressió. Aquests objectes tenen la particularitat que es poden avaluar en temps d\u0026rsquo;execució i justament això és el que fa EF per generar el SQL. Com a programadors nosaltres mai creem directament objectes Expression\u0026lt;T\u0026gt; si no que deixem que el compilador ho faci per nosaltres, a partir d\u0026rsquo;un delegat, que habitualment expresem en forma d\u0026rsquo;una expressió lambda. P. ex. el compilador pot convertir x =\u0026gt; x+1 a una Expression\u0026lt;T\u0026gt; a on T sigui compatible amb el delegat proporcionat com p. ex. Expression\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt;:\n1  Expression\u0026lt;Func\u0026lt;int, int\u0026gt;\u0026gt; expr = x =\u0026gt; x + 1; // OK   Com ja s\u0026rsquo;ha dit, EF fa servir aquestes expressions per generar el SQL final i aquestes expressions es construeixen a partir dels delegats que passem quan fem servir els diferents mètodes de LINQ. Això planteja un problema: què passa si EF no sap generar el SQL d\u0026rsquo;una determinada expressió?\nAnem a veure un exemple. Partirem de la següentt aplicació de terminal (netcore 3):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static void Main(string[] args) { Console.WriteLine(\u0026#34;Creating DbContext...\u0026#34;); var lf = LoggerFactory.Create(c =\u0026gt; c .AddFilter(\u0026#34;*\u0026#34;, LogLevel.Debug) .AddConsole()); var builder = new DbContextOptionsBuilder\u0026lt;FooContext\u0026gt;() .UseSqlServer(\u0026#34;Data Source=(LocalDb)\\\\MSSQLLocalDB;Initial Catalog=foo;Integrated Security=SSPI\u0026#34;) .UseLoggerFactory(lf); var ctx = new FooContext(builder.Options); ctx.Database.EnsureCreated(); if (!ctx.Persons.Any()) { ctx.Persons.Add(new Person() { Name = \u0026#34;Baby Monster\u0026#34;, Age = 2 }); ctx.Persons.Add(new Person() { Name = \u0026#34;Young Monster\u0026#34;, Age = 14 }); ctx.Persons.Add(new Person() { Name = \u0026#34;Adult Monster\u0026#34;, Age = 30 }); ctx.Persons.Add(new Person() { Name = \u0026#34;Senior Monster\u0026#34;, Age = 70 }); ctx.SaveChanges(); } Console.WriteLine(\u0026#34;\u0026#39;Simple query\u0026#39;\u0026#34;); var adults = ctx.Persons.Where(p =\u0026gt; p.Age \u0026gt; 17).ToList(); }   La classe FooContext és tot just un DbSet\u0026lt;Person\u0026gt;:\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class FooContext : DbContext { public FooContext(DbContextOptions\u0026lt;FooContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Person\u0026gt; Persons { get; set; } } public class Person { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } }   L\u0026rsquo;aplicació mostra pel terminal les consultes generades per EF, i aquest es el log que podem veure:\nExecuting DbCommand [Parameters=[], CommandType='Text', CommandTimeout='30'] SELECT [p].[Id], [p].[Age], [p].[Name] FROM [Persons] AS [p] WHERE [p].[Age] \u0026gt; 17 D\u0026rsquo;acord. EF ha generat la sentència SQL esperada a partir de la nostra expressió LINQ. Ara bé, imagina que decidim refactoritzar això i eliminar aquest 17 d\u0026rsquo;aquí i encapsular-lo en una funció:\n1  private static bool IsAdult(Person p) =\u0026gt; p.Age \u0026gt; 17   Després, òbviament, modifiques el teu codi LINQ:\n1  var adults = ctx.Persons.Where(p =\u0026gt; IsAdult(p)).ToList();   Aquest codi compila (a fi de comptes p =\u0026gt; IsAdult(p) es un delegat perfectament vàlid i per tant es pot crear un arbre d\u0026rsquo;expressió). Però\u0026hellip; funciona? Doncs bé, si fas servir EF 2.x o anterior, aparentment sí. L\u0026rsquo;aplicació s\u0026rsquo;executa i el resultat és el mateix. Però si et fixes en el log d\u0026rsquo;EF:\nExecuting DbCommand [Parameters=[], CommandType='Text', CommandTimeout='30'] SELECT [p].[Id], [p].[Age], [p].[Name] FROM [Persons] AS [p] Ho veus? El WHERE ja no hi és! Fixa\u0026rsquo;t que EF s\u0026rsquo;està traient tots els registres de la taula. Val, el què ha passat és el següent: Quan EF ha de convertir el codi LINQ a SQL, es troba una crida a IsAdult(p) i no sap com traduir-ho a SQL. Per tant, en aquest punt, deixa de generar SQL i continuarà l\u0026rsquo;avaluació en memòria. Això és el que passarà:\n S\u0026rsquo;executarà el resultat de traduir Persons (que és recuperar tots els registres de la taula) El resultat anirà a memòria (en un IEnumerable\u0026lt;Person\u0026gt;) En memòria s\u0026rsquo;executarà la resta de la consulta LINQ (el Where)  Aquesta característica (de continuar consultes en memòria) és precisament el que anomenem \u0026ldquo;avaluació en client\u0026rdquo;.\nSi la BBDD té pocs registres, això no ho notaràs (o quasi), però imagina una taula amb milions de regitres\u0026hellip;\nHonestament, l\u0026rsquo;avaluació en client és una pèssima característica. Penso que estava en les primeres versions d\u0026rsquo;EF, perquè aquestes primeres versions (sobretot EF 1.x) no era capaç de generar SQL per a alguns casos quasi trivials. Ara bé, un consell: si fas servir EF 2.x desactiva-la. Per això nomès has de generar el següent codi al crear el DbContextOptionsBuilder:\n1  ConfigureWarnings(w =\u0026gt; w.Throw(RelationalEventId.QueryClientEvaluationWarning))   Amb aquest codi, cada vegada que EF no pugui traduir LINQ a SQL, es llançarà una excepció en comptes d\u0026rsquo;avaluar en client. I això és molt millor, creu-me, perque així te n\u0026rsquo;adones que aquesta consulta no es pot executar a BBDD. I millor adonar-te\u0026rsquo;n en la fase de proves que no pas perquè cau producció, no?\nA EF 3.x l\u0026rsquo;avaluació en client està desactivada ja de sèrie (el codi anterior funciona, senzillament no fa res), per tant ja rebries l\u0026rsquo;excepció sense necessitat d\u0026rsquo;afegir el codi anterior. Aquesta decisió és un breaking change, però crec que és una gran decisió. EF 3.x ja està molt més madur i és capaç de generar SQL en una gran varietat d\u0026rsquo;escenaris. No hi ha necessitat de tenir una bomba de rellotgeria activa com és l\u0026rsquo;avaluació en client.\nObligar a l\u0026rsquo;avaluació en client A vegades ens pot interessar obligar a l\u0026rsquo;avaluació en client, més que res perquè no hi ha manera humana d\u0026rsquo;escriure part de la consulta d\u0026rsquo;una forma que es pugui traduir a SQL. Podem forçar l\u0026rsquo;avaluació en client de part d\u0026rsquo;una query cridant a AsEnumerable():\n1 2  var adults = ctx.Persons.Where(p =\u0026gt; p.Age \u0026gt; 17). AsEnumerable().Where(p =\u0026gt; p.Name.StartsWith(\u0026#34;Se\u0026#34;)).ToList();   Si ara observes el log d\u0026rsquo;EF el que veuràs serà:\nExecuted DbCommand (2ms) [Parameters=[], CommandType='Text', CommandTimeout='30'] SELECT [p].[Id], [p].[Age], [p].[Name] FROM [Persons] AS [p] WHERE [p].[Age] \u0026gt; 17 Pots veure com un cop hem cridat a AsEnumerable() passem a avaluar en client i la verificació de que el nom comenci per Se es fa en client, no en la BBDD.\nAvaluar en client sense voler Forçar l\u0026rsquo;avaluació en client està bé, el problema és quan ho fem sense voler. I com que l\u0026rsquo;hem forçada EF no ens avisarà de cap manera.\n1 2 3 4 5 6 7 8 9  var adults = ctx.Persons.Adults().ToList(); // ... static class MyExtensions { public static IEnumerable\u0026lt;Person\u0026gt; Adults (this IEnumerable\u0026lt;Person\u0026gt; source) { return source.Where(p =\u0026gt; p.Age \u0026gt; 17); } }   Com veus aquest codi? Tot bé no? EF no es queixa, l\u0026rsquo;aplicació segueix retornant els resultats correctes\u0026hellip; però observa el log:\nExecuted DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30'] SELECT [p].[Id], [p].[Age], [p].[Name] FROM [Persons] AS [p] Al passar la condició a un mètodo d\u0026rsquo;extensió sobre IEnumerable s\u0026rsquo;ha forçat l\u0026rsquo;avaluació en client. A tots els efectes és com si invoquessis a AsEnumerable(). Per tant EF no t\u0026rsquo;avisarà perquè pressuposa que saps el què estàs fent. Aquest error l\u0026rsquo;he vist en molts casos.\nSi vols encapsular consultes en mètodes separats, has de declarar-los sobre IQueryable, no sobre IEnumerable.\n1 2 3 4  public static IQueryable\u0026lt;Person\u0026gt; Adults (this IQueryable\u0026lt;Person\u0026gt; source) { return source.Where(p =\u0026gt; p.Age \u0026gt; 17); }   Declarar el mètode sobre IEnumerable funciona perquè IQueryable hereta de IEnumerable. Però quan fem servir IEnumerable estem fent servir sempre avaluació en client. El per què passa això té a veure amb la combinació de dos aspectes de C#:\n El dispatch dels mètodes d\u0026rsquo;extensió es sempre en temps de compilació. Els mètodes de LINQ de IEnumerable treballan amb delegats, no amb arbres d\u0026rsquo;expressió.  Comencem amb el segon punt. El mètode Where de IEnumerable està definit així:\n1  public static IEnumerable\u0026lt;TSource\u0026gt; Where\u0026lt;TSource\u0026gt;(this IEnumerable\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, bool\u0026gt; predicate);   Per la seva banda el mètode Where de IQueryable està definit de forma diferent:\n1  public static IQueryable\u0026lt;TSource\u0026gt; Where\u0026lt;TSource\u0026gt;(this IQueryable\u0026lt;TSource\u0026gt; source, Expression\u0026lt;Func\u0026lt;TSource, bool\u0026gt;\u0026gt; predicate);   Efectivament, en el segon cas el paràmetre és un arbre d\u0026rsquo;expressió (Expression), i en el primer és simplement un delegat tal qual. El Where de IEnumerable no permet que EF analitzi res. No es pot transformar un delegat a SQL, perquè un delegat no es pot analitzar. Per això ens cal un arbre d\u0026rsquo;expressió.\nI ara entra en joc el primer dels dos punts d\u0026rsquo;abans: els mètodes d\u0026rsquo;extensió es seleccionen en temps de compilació. Això el què vol dir és que si tenim:\n1  source.Where(p =\u0026gt; p.Age \u0026gt; 17);   Quan el compilador ha de generar el codi per invocar al Where ho fa en funció del tipus de la variable source. Ho repeteixo perquè és la clau: en funció del tipus de la variable, no pas en funció del tipus real de l\u0026rsquo;objecte referenciat per la variable. No importa que l\u0026rsquo;objecte \u0026ldquo;real\u0026rdquo; sigui un IQueryable: si source és del tipus IEnumerable, s\u0026rsquo;invocarà al mètode d\u0026rsquo;extensió de IEnumerable. Perque aquesta decisió la pren el compilador (no el CLR) i el compilador nomès pot saber el tipus de la variable.\nPer tant, compte en definir mètodes sobre IEnumerable per que és una manera de forçar l\u0026rsquo;avaluació en client.\nAra bé, vull deixar clar que el problema és que s\u0026rsquo;acava invocant al Where de IEnumerable, no pas que el nostre mètode d\u0026rsquo;extensió estigui definit sobre IEnumerable (malgrat les dos coses van molt relacionades). Per exemple, el següent mètode d\u0026rsquo;extensió Adults() està definit sobre IEnumerable però no força l\u0026rsquo;avaluació en client:\n1 2 3 4 5 6 7 8 9 10 11 12  public static IEnumerable\u0026lt;Person\u0026gt; Adults(this IEnumerable\u0026lt;Person\u0026gt; source) { return source.CWhere(p =\u0026gt; p.Age \u0026gt; 17); } public static IEnumerable\u0026lt;T\u0026gt; CWhere\u0026lt;T\u0026gt;(this IEnumerable\u0026lt;T\u0026gt; source, Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate) { if (source is IQueryable\u0026lt;T\u0026gt;) { return ((IQueryable\u0026lt;T\u0026gt;)source).Where(predicate); } return source.Where(predicate.Compile()); }   Aquí la clau és que CWhere analitza (en temps d\u0026rsquo;execució) si l\u0026rsquo;objecte implementa o no IQueryable i en funció del resultat invoca directament el mètode Where que toca (observa el cast a IQueryable\u0026lt;T\u0026gt;). Obviament, tot el que encadenessim després de Adults() s\u0026rsquo;avaluaria en client (perquè Adults() retorna un IEnumerable\u0026lt;T\u0026gt;).\nAvaluació mandrosa (lazy evaluation) No s\u0026rsquo;ha de confondre l\u0026rsquo;avaluació en client amb l\u0026rsquo;avaluació mandrosa (lazy). L\u0026rsquo;avaluació mandrosa vol dir que fins que no es recorrin els objectes de un IEnumerable no s\u0026rsquo;avaluarà aquest IEnumerable. Això passa també amb els IQueryable, per tant tenim avaluació mandrosa tant a BBDD com en client. Es quelcom inherent a .NET, no ho podem desactivar.\nAixò vol dir que si tinc aquesta consulta LINQ:\nvar adults = ctx.Persons.Where(p =\u0026gt; p.Age \u0026gt; 17); La variable adults conté el resultat, però no es generarà fins que es recorri aquest resultat. Aquest recorregut pot ser amb un foreach o bé \u0026ldquo;materialitzant\u0026rdquo; el resultatt (p. ex. cridant a .ToList() per a copiar el resultat en una llista).\nEn aquest punt hi ha una diferència super importnat entre l\u0026rsquo;avaluació mandrosa en client i l\u0026rsquo;avaluació mandrosa en BBDD:\n L\u0026rsquo;avaluació mandrosa en BBDD es ejecutar el SQL L\u0026rsquo;avaluació mandrosa en client és generar els elements del IEnumerable a mesura que es necessiten  Què vull dir amb això? Doncs que si tens una consulta com la següent (a on Adults() està definit sobre IEnumerable i per tant ens força l\u0026rsquo;avaluació en client):\n1 2 3 4 5 6 7  Console.WriteLine(\u0026#34;\u0026#39;Simple query\u0026#39;\u0026#34;); var adults = ctx.Persons.Adults(); Console.WriteLine(\u0026#34;Iterating results\u0026#34;); foreach (var a in adults.Take(1)) { Console.WriteLine(a.Name); }   El log que ara veuràs serà semblant a:\n'Simple query' Iterating results Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30'] SELECT [p].[Id], [p].[Age], [p].[Name] FROM [Persons] AS [p] Adult Monster Fixa\u0026rsquo;t que no s\u0026rsquo;executa la consulta SQL fins que no comencem a iterar, però clar, aquesta consulta s\u0026rsquo;emporta tots els registres de la BBDD. És indiferent que després facis un Take(1), aquest Take és en client. En aquest cas la situació es:\n Comencem a iterar S\u0026rsquo;executa UNA SOLA VEGADA la consulta SQL (i s\u0026rsquo;emporta, en aquest cas, tots els registres) Es generen un a un tots els elements del IEnumerable (en aquest cas nomès n\u0026rsquo;hi ha un pel Take)  El punt positiu de l\u0026rsquo;avaluació mandrosa és que et permet realitzar les consultes LINQ quan vulguis, però no pagaràs el preu fins que les recorris o les materialitzis (cridant a ToList() o similar, pensa que AsEnumerable() no materialitza res).\nEspero que aquesta entrada t\u0026rsquo;hagi ajudat a entendre com funciona l\u0026rsquo;avaluació en client a EF.\n","description":"Anem a repassar conceptes bàsics, però que et poden fer ballar el cap com no vigilis. Concretament, com assegurar-te de que totes les teves consultes LINQ amb EF s'executen realment a la BBBDD. Som-hi!","id":0,"section":"posts","tags":null,"title":"EF memòria i BBDD","uri":"https://www.eiximenis.dev/ca/posts/2020-04-08-ef-memoria-y-bbdd/"},{"content":"Abans de parlar sobre el com podem crear operadores, millor que veguem què és un operador, per a què el podem fer servir i quins avantatges ens aporta respecte altres mecanismes similars. Som-hi!\nUn operador és una forma de desplegar i mantenir aplicacions per a Kubernetes. La clau, aquí, és \u0026ldquo;per a\u0026quot;. O sigui, no estem parlant de desplegar una aplicació en un Kubernetes. Estem parlant de desplegar una aplicación per a Kubernetes, i això implica que farem servir kubectl no nomès per al desplegament, si no també pel manteniment i la configuració. És a dir, l\u0026rsquo;aplicació s\u0026rsquo;instal·la, es manté i es configura fent servir la API de Kubernetes i totes les eines associades (començant per kubectl).\nEl concepte d\u0026rsquo;operador fou introduit per la gent de CoreOS y es fonamenta en dos altres conceptes claus de Kubernetes, que hem d\u0026rsquo;entendre per poder comprendre com funcionen els operadors:\n Recursos: Un recurs en Kubernetes és un objecte que defineix un estat desitjat. Així, el recurs ReplicaSet permet definir el nombre de instàncies d\u0026rsquo;un determinat pod que es vol tenir sempre en execució. Controladors: Un controlador per la seva banda s\u0026rsquo;encarrega de monitoritzar un recurs i assegurar-se que l\u0026rsquo;estat real del clúster és compatible amb l\u0026rsquo;estat desitjat. En cas que això no sigui així, ha de prendre les accions necessàries per reconciliar els dos estats. Per exemple, el controlador de ReplicaSet s\u0026rsquo;encarrega de garantir que el nombre de pods reals en execució és sempre el nombre definir en el recurs ReplicaSet associat, creant i destruint pods sempre que calgui.  Controladors a Kubernetes Els recursos els gestionem amb els fitxers YAML, però els controlaors son codi que s\u0026rsquo;executa en el clúster. A vista d\u0026rsquo;ocell podem entendre un controlador com un \u0026ldquo;bucle etern\u0026rdquo; que realitza les següents accions:\n Consultar l\u0026rsquo;estat actual del clúster Si l\u0026rsquo;estat actual és el desitjat, no fer res. Però si no, utilitzar la API de Kubernetes per a modificar l\u0026rsquo;estat del clúster  Una representació, un pel més acurada, es pot veure en el següent diagrama:\nAquest esquema, adaptat de la documentació oficial, mostra amb una mica més de detall com funciona un controlador (està basat en els components que defineix la llibreria client-go). Introdueixo aquests termes perque son rellevants en el cas que vulguis cercar més informació.\n El controlador es subscriu a determinats events de la API de Kubernetes per a monitoritzar creacions, eliminacions o actualitzacions de recursos. A cada tipus de recurs se li asigna un informer que rebrà nomès els events del tipus de recurs indicat L\u0026rsquo;event es guarda en una cua de treball, mentres que l\u0026rsquo;estat del objecte es guarda en una cache Finalment la logica de reconciliació treballa amb l\u0026rsquo;event de la cua, la definició que està a la cache i la API de Kubernetes per realitzar les accions necessàries.  El diagrama anterior mostra un detall imporant: els operadors s\u0026rsquo;executen en pods, cosa que vol dir que instal·lar un operador consisteix simplement en desplegar fitxers YAML al clúster.\nControladors vs Operadors Tots els operadors fan servir el patró de controlador (i per tant en defineixen algun). Però no tots els controladors son operadors. Pots fer servir un controlador sense res més, quan necessitis reaccionar a un tipus de recurs, però els operadors van un pèl més enllà, ja que:\n Defineixen un o més controladors Defineixen un o més CRDs Gestionen el cicle de vida Estan orientats a una aplicació  L'últim punt és important: un operador està dedicat a una aplicació. Si aquesta aplicació requereix altres aplicacions, hauries de fer servir altres operadors, per aquestes aplicacions. Per exemple, pots tenir un operador encarregat d\u0026rsquo;instal·lar un, posem pel cas, wordpress. Però si wordpress depèn de mysql, hauries d\u0026rsquo;usar un altre operador pel mysql.\nEls altres tres punts posen de manifest les diferències entre operadors i controladors: un operador és un (o mès d\u0026rsquo;un) controlador amb un conjunt de CRDs que permeten configurar i mantenir la aplicació fent servir la API de Kubernetes. I per acabar: un operador sol mantenir el cicle de vida de l\u0026rsquo;aplicació que gestiona, creant i destruint els pods necessaris.\nAgafem d\u0026rsquo;exemple l\u0026rsquo;operador de Prometheus. Aquest operador instal·la varis CRDs, dels quals en destaquen un anomenat monitoring.coreos.com/v1/Prometheus que representa al propi Prometheus i un altre que és monitoring.coreos.com/v1/ServiceMonitor que defineix quins serveis han de ser monitoritzats (per prometheus). Si instal·les l\u0026rsquo;operador de Prometheus, no has de fer servir cap deployment per instal·lar un Prometheus al teu clúster: nomès has de crear un CRD de tipus Prometheus. La imatge que vé a continuació mostra un Prometheus (de nom k8s) desplegar a l\u0026rsquo;espai de noms monitoring:\nFixa\u0026rsquo;t com el propi CRD de Prometheus defineix les repliques (2 en aquest cas) i és el propi operador el que s\u0026rsquo;encarrega de crear i destruir els pods que executen Prometheus (no hi ha cap deployment ni replicaset).\nOperadors vs Helm No se suposa que per instal·lar aplicacions a Kubernetes disposem de Helm? Hi ha un cert solapament entre algunes de les responsabilitats d\u0026rsquo;un operador i les de Helm: en ambdós casos tenim mecanismes per a gestionar workloads complexos. Si instal·lar la teva aplicació és un procés d\u0026rsquo;un sol pas i no requereixes que aquesta es gestioni a través d\u0026rsquo;objectes de Kubernetes, llavors Helm és el que hauries de considerar. Per altra banda, si la teva aplicació requereix aquest tipus de gestió (a través d\u0026rsquo;objectes de Kubernetes), llavors hauries de pensar en crear un operador. I tingues present que, com que desplegar un operador consisteix en desplegar els seus fitxers YAML, no hi ha res que t\u0026rsquo;impedeixi fer-ho amb Helm.\nÉs bona pràctica instal·lar els CRDs que el teu operador defineixi, via YAML en comptes de fer-ho via codi al operador. La raó és per seguretat: desplegar un CRD requereix permisos d'àmbit de clúster, mentres que el teu operador, probablement, no necessita uns permisos tan elevats per fer la seva feina habitual. Però si instal·les els CRDs via codi, llavors has d\u0026rsquo;assignar permisos de clúster al pod que executa l\u0026rsquo;operador, trencant el principi de mínim privilegi. Així, pots definir tots els CRDs a un chart de Helm i que els instal·li juntament amb el deployment que executi l\u0026rsquo;operador i la resta d\u0026rsquo;elements necessaris. Això sí, tingues present que has d\u0026rsquo;indicar-li a Helm que instal·li els CRDs abans que la resta d\u0026rsquo;elements, ja que si no, tindràs problemes. Com fer això depèn de si uses Helm 2.x o 3.x.\nConclusió En aquest primer post hem cobert el bàsic que necessites saber sobre operadors a Kubernetes. En els posts que venen veurem com crear un operador i com desplegar-lo!\n","description":"Som-hi! Anem a començar la sèrie sobre com crear operadors per a Kubernetes. En aquest primer post veurem què és un operador de Kubernetes i quins usos té.","id":1,"section":"posts","tags":null,"title":"El patró operador a Kubernetes","uri":"https://www.eiximenis.dev/ca/posts/2020-04-06-el-patron-operador-en-k8s/"},{"content":"Sempre he pensat que escriure un blog serveix per a vàries coses.\nPrimer per aprendre, escriure sobre un tema és una de les millors formes de forçar-se a un mateix a aprendre. Només per això val la pena escriure!\nSegon, per a compartir experiències i coneixements. Molta gent té por d\u0026rsquo;escriure perquè NO considera que estigui a l\u0026rsquo;alçada. A l\u0026rsquo;alçada de què? Habitualment d\u0026rsquo;unes expectatives falsament auto-imposades. Molts cops ens pensem que no podem dir res que ja estigui dit. I dit per algú que en sap més que nosaltres. Mira, tant si ets un júnior que comença en aquest mon, com si tens el cul pelat, tens una cosa única a compartir i que ningúi pot haver dit abans: les teves experiències. Acabes de jugar uns dies amb una llibrería nova de JavaScript? Doncs comparteix el que t\u0026rsquo;ha semblat o com t\u0026rsquo;has enfrontat al procés d\u0026rsquo;aprendre a usar-la. Després, potser t\u0026rsquo;animes a escriure un petit article d\u0026rsquo;iniciació i així anar fent\u0026hellip;\nJo, com molta gent, he tingut la idea d\u0026rsquo;escriure en anglès en algun moment. Però al final sempre ho he descartat. Escriure en anglès és temptador: et permet arribar a una gran base de gent i aspirar a una major rellevància. Personalment, aquests aspectes no m\u0026rsquo;importen gens i sempre he volgut aportar i compartir en el meu idioma i posar el meu granet de sorra i generar contingut que no estigui en anglès. Així que sempre he escrit en castellà i ho seguiré fent. Però alhora penso en la situació del meu altre idioma, el català. I des d\u0026rsquo;aquí vull aportar un altre granet de sorra, publicant contingut en català. Pot semblar superflu, ja que tothom qui sap català sap també castellà, però no ho faig per aconseguir nous lectors: ho faig perquè tots aquells que vulguin llegir en català ho puguin fer i per a que hi hagi contingut en català i contribuir, modestament, a normalitzar la situació de la llengua.\nL\u0026rsquo;idioma principal del blog seguirà sent el castellà, però intentaré anar traduint alguns articles antics (però encara rellevants) del castellà al català i que tot lo nou surti en ambdós idiomes. Potser no alhora (tinc el temps que tinc per a poder dedicar al blog), però en el menor temps possible.\nNo crec que hi hagin entrades només en català, tot i que no ho descarto si comento alguna cosa d\u0026rsquo;interès més local. En tot cas, no serà la norma habitual.\nUna abraçada i cuideu-vos!\n","description":"No, no em refereixo a aquest blog... em refereixo al llibre (o sèrie de llibres depèn de com es miri) publicats pel franciscà i teòleg Fra Francesc Eiximenis. I si ell va escriure en català, no veig per què jo no puc fer-ho. En resum: que publucaré també articles en català. Si vols més detalls... segueix llegint!","id":2,"section":"posts","tags":null,"title":"El 'Lo Crestià' original estava escrit en català...","uri":"https://www.eiximenis.dev/ca/posts/2020-03-26-lo-crestia-originalment-era-en-catala/"}]